---
title: "Design"
editor: visual
---

## Learning outcomes

You will know how to:

-   Build a neat Shiny app from start to finish
-   Create simple but appealing user interfaces
-   Upgrade your apps using custom theming
-   Combine Shiny with common interfaces like Leaflet, Plotly and Datatable

## Building a Shiny app

-   The following sections will introduce you to the Shiny app building process

-   The course is guided by a Shiny app that was created for this workshop (for the code click [here](https://github.com/paulcbauer/shiny_workshop/tree/main/shinyapps/guerry), for the final app click )

-   You may follow the existing code closely, or freestyle and create your own app entirely

## Planning

![Stages of app development](resources/app-design.svg)

-   One might think of app development as a non-linear 5-step-process:
    -   Design
    -   Prototype
    -   Build
    -   Strengthen
    -   Deploy
-   In UX design, app development is often guided by the notion of a *minimum viable product* or MVP.
-   Central idea: Building a first working example, even if bad, is better than having nothing for most of the development process
-   To build such a prototype we need to plan a bit upfront
-   Some good questions to ask yourself:
    -   What type of app do you want to build (e.g. a web dashboard, a mobile app, a programmatic API, ...)?
    -   How many users are going to use the app?
    -   What type of users will be using your app (e.g., professionals vs. laypeople, old vs. young, ...)?

**Excercise:** Think of a Shiny app that you would like to develop. Try to come up with questions that might help you create a nice design for a first prototype.

In the following course modules, we will follow these principles. We will:

1.  Design and prepare the concept of an app
2.  Build a (loosely defined) prototype of the app (a UI object)
3.  Add functionality to the app (a server function)
4.  Talk about deployment

## Prerequisites

For building our app we will make use of a range of packages that go beyond shiny. This includes packages that extend Shiny functionalities, but also others that provide data or ways to work with that data:

```{r}
pacman::p_load(
	shiny,
	htmltools,
	bs4Dash,
	fresh,
	waiter,
	shinyWidgets,
	Guerry,
	sf,
	tidyr,
	dplyr,
	RColorBrewer,
	viridis,
	leaflet,
	plotly,
	jsonlite
)
```

## The data

In real use cases of Shiny, the choice of data will probably not be a problem. Here, however, we need to decide on a dataset that constitutes the basis for our app endeavours. If you already have a dataset in mind, feel free to use it here. I will use the Guerry dataset, a spatial dataset containing some interesting social data from 19th century France compiled by statistician André-Michel Guerry in 1833.

![Guerry's map on crime against persons (Source: https://en.wikipedia.org/wiki/André-Michel_Guerry)](https://upload.wikimedia.org/wikipedia/en/c/c6/AMGuerry-carte1-low.jpg)

To load the data, we can use the [`Guerry`](https://cran.r-project.org/web/packages/Guerry/) package. However, we need to apply some cleaning steps to get the dataset up and running:

```{r}
guerry <- Guerry::gfrance85 %>%
  st_as_sf() %>% # convert sp to the newer sf format
  as_tibble() %>%
  st_as_sf(crs = 27572) %>% # set the correct coordinate reference system
  mutate(Region = case_match(
    Region,
    "C" ~ "Central",
    "E" ~ "East",
    "N" ~ "North",
    "S" ~ "South",
    "W" ~ "West"
  ))
guerry
```

**Question:** Are there specific datasets that you would like to build a Shiny app around? If so, tell us about it. What kind of visualizations could be possible with your dataset?

## The structure

-   **Question:** Given the dataset (or your own dataset), what is the app supposed to do?

-   **Question:** What is the goal / research question / objective?

-   Here, I want to showcase an exploratory (spatial) data analysis and structure the dashboard like so:

    -   Introduction

    -   Data exploration (map distributions)

    -   Data modelling (assess relationships)

    -   Data inspection (examine raw data)

## The tools

-   Like R, Shiny only provides a framework but leaves the rest to the ambitious tool developer

-   Like R, Shiny has many extensions which facilitate app development without knowledge of CSS or JavaScript

-   Unlike R, Shiny has no dedicated package database (like CRAN or Bioconductor)

-   Alternative: [![](awesome-logo.svg)](https://github.com/nanxstats/awesome-shiny-extensions)

**Exercise:** Consult the [awesome list of Shiny extensions](https://github.com/nanxstats/awesome-shiny-extensions) and write down tools that you think sound useful for building your Shiny app.

## Preparation

-   Data wrangling steps that do not depend on user input should not be done in reactives or observers

-   [Do]{style="color:green;"}: Bring data into shape before using it in a Shiny app

-   [Don't]{style="color:red;"}: Perform unnecessary data wrangling each time a reactive object is invalidated

-   Especially unpleasant when dealing with expensive operations like aggregation or pivoting

As you can see above, the Guerry dataframe contains a bunch of numeric variables, a geometry column, two place variables and a few metadata columns. To proceed I isolate the variable names:

```{r}
variables <- guerry %>%
  st_drop_geometry() %>%
  select(where(is.numeric) & !all_of(c("COUNT", "dept", "AVE_ID_GEO"))) %>%
  names()
```

The dataset also contains two columns containing place names: `Department` and `Region`. For cross-level analyses, I would like my dataset to be aggregated on both levels. To do that, I perform a spatial aggregation for all numeric variables.

```{r}
guerry_region <- guerry %>%
  group_by(Region) %>%
  summarise(across(
  .cols = all_of(variables),
  function(x) {
    if (cur_column() %in% c("Area", "Pop1831")) {
      sum(x)
    } else {
      mean(x)
    }
  }
))
guerry_region
```

Finally, I like to pivot the Guerry dataset to enable a more comfortable way of exploring the raw data:

```{r}
guerry_long <- tidyr::pivot_longer(
  st_drop_geometry(guerry),
  cols = all_of(variables),
  names_to = "variable"
) %>%
  mutate(variable = factor(variable, levels = unique(variable))) %>%
  arrange(variable)

guerry_region_long <- tidyr::pivot_longer(
  st_drop_geometry(guerry_region),
  cols = all_of(variables),
  names_to = "variable"
) %>%
  mutate(variable = factor(variable, levels = unique(variable))) %>%
  arrange(variable)
```

## Data storage

-   Things might get tricky for more data-hungry Shiny apps

-   The way data is stored and accessed has some important implications for

    -   Memory allocation: R stores objects in the working memory

    -   Performance: "R does too much" - Colin Fay

    -   Readability: Putting everything in one file might get messy

-   For the Guerry app, I created a separate R code file which exports all the text elements into a JSON file:

```{r}
txts <- read_json("shinyapps/guerry/app_labels.json", simplifyVector = TRUE)
```

-   For more sophisticated setups: **databases** (e.g., SQLite, PostgreSQL, MongoDB)

-   R can work perfectly well with database connections (R Packages: DBI, dbplyr, sf)

-   SQLite works well for casually trying out databases
