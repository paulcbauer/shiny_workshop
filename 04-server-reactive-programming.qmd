--- 
title: "Server & reactive programming"
---

- Learning outcomes:
  - Understand logic underlying reactivity in Shiny apps

Sources: [@wickham2021mastering, Ch. 3]

```{r 04-server-reactive-programming-1, message=FALSE, warning=FALSE, include=FALSE}
# namer::unname_chunks("04-server-reactive-programming.qmd")
# namer::name_chunks("04-server-reactive-programming.qmd")

# install.packages("pacman)
pacman::p_load(knitr, quarto)
```



* See preparation in design
- bind_event, bind_cache (maybe not the latter)







## Basics
- In Shiny, server logic is expressed using **reactive programming** (*elegant powerful programming paradigm!*)
- Very different to writing a script that runs from start to end
- Key idea: specify a graph of dependencies so that when an input changes, all related outputs (throughout the script) are automatically updated
- **Reactive programming** makes flow of an app considerably simpler


## The server function
- "Guts" of every shiny app below

```{r 04-server-reactive-programming-2, echo=FALSE, eval=FALSE, include=FALSE}
library(shiny)

# front end interface (Html)
ui <- fluidPage()

# back end logic
server <- function(input, output, session) {}

shinyApp(ui, server)
```

- `ui` simple because every user gets same html
- `server` more complicated because every user needs independent version of the app (i.e., A using slider should not affect B's ui)
- `server()` is invoked each time new session starts
  - has three parameters: `input`, `output`, `session` that are created by Shiny (not by us!) when session starts  connecting to specific session



## Input & output
- `input` argument is list-like object that contains all the **input data sent from the browser**, named according to the **input ID**
  - e.g., `numericInput("count", label = "Number of values", value = 100)` generates `input$count`
  - `input` is selective about who is allowed to read from i
    - namely you must be in a reactive context created by a function like `renderText()` or `reactive()`
    - these functions allow for outputs to automatically update when an input changes

- `output` is similar to input: a list-like object containing ouputs named according to `output ID`
  - Difference: `output` used for sending output instead of receiving input (always in concert with **render function** as below)
  
```{r 04-server-reactive-programming-3, echo=FALSE, eval=FALSE, include=FALSE}
ui <- fluidPage(textOutput("greeting"))

server <- function(input, output, session) {
  output$greeting <- renderText("Hello human!")
}

shinyApp(ui, server)
```

- **render function** sets up special reactive context that automatically tracks what inputs the output uses AND converts output of R code into HTML suitable for display on a web page
- Common errors: Forgetting render function or reading from outputs (see [here](https://mastering-shiny.org/basic-reactivity.html#output))



## Render functions

- **render functions** wrap outputs and correspond to the type or reactive output
- `renderImage({...})` creates images (saved as a link to a source file)
- `renderPlot({...})` creates plots
- `renderPrint({...})` creates any printed output
- `renderTable({...})` creates data frame, matrix, other table like structures
- `renderText({...})` creates character strings
- `renderUI({...})` creates a Shiny tag object or HTML



## Reactive programming 
### How does reactivity work? {#sec-name-app}

* How does reactivity work? Let's look at the example below!

```{r 04-server-reactive-programming-4, echo=TRUE, eval=FALSE}
ui <- fluidPage(
  textInput("name", "What's your name?"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  output$greeting <- renderText({
    paste0("Hello ", input$name, "!")
  })
}
shinyApp(ui, server)
```

- Big idea in Shiny: you don’t need to tell an output when to update, because Shiny automatically figures it out for you!
- Shiny performs the action every time we update `input$name`
- **reactive** refers to any expression that automatically updates itself when its dependencies change
- Code doesn't tell Shiny to create string and send it to the browser, but instead informs Shiny how it could create the string if it needs to
  - It's up to Shiny when (and even if!) the code should be run
- App provides Shiny with **recipes**, not giving it commands

### Imperative vs. Declarative programming and laziness

- **Imperative vs. Declarative programming** ([Chapter 3.3.1](https://mastering-shiny.org/basic-reactivity.html#imperative-vs-declarative-programming))
  - Imperative code: "Make me a sandwich"; Declarative code: "Ensure there is a sandwich in the refrigerator whenever I look inside of it"
  - Imperative code is assertive; declarative code is passive-aggressive
- **Laziness**  ([Chapter 3.3.2](https://mastering-shiny.org/basic-reactivity.html#laziness))
  - Strength of **declarative programming**: app will only ever do the minimal amount of work needed to update the output controls that you can currently see

### The reactive graph
- Most R code can be read from top to bottom (= order of execution)... not in Shiny!
- **Reactive graph**: describes how inputs and outputs are connected to understand order of execution
- @fig-graph-simple describes app in @sec-name-app above.

```{r 04-server-reactive-programming-5, echo = FALSE, out.width = NULL}
#| label: fig-graph-simple
#| fig-cap: "The reactive graph shows how the inputs and outputs are connected (Source: Wickham 2021)"
knitr::include_graphics("resources/graph-1b.png", dpi = 300)
```

- Graph tells you that `greeting` will need to be recomputed whenever `name` is changed (`greeting` has a reactive dependency on `name`)
- Quick high-level sketch of the reactive graph to remind you how all the pieces fit together


### Reactive expressions
- **Reactive expressions** take inputs and produce outputs so they have a shape that combines features of both inputs and outputs
- Think of them as a tool to reduce duplication in your reactive code by introducing additional nodes into the reactive graph (see @fig-graph-expression)

```{r 04-server-reactive-programming-6, echo = FALSE, out.width = NULL}
#| label: fig-graph-expression
#| fig-cap: "A reactive expression is drawn with angles on both sides because it connects inputs to outputs (Source: Wickham 2021)"
knitr::include_graphics("resources/graph-2b.png", dpi = 300)
```

- Below we add one (i.e., `reactive()`) to the app in @sec-name-app above:


```{r 04-server-reactive-programming-7, echo=TRUE, eval=FALSE}
ui <- fluidPage(
  textInput("name", "What's your name?"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  string <- reactive(paste0("Hello ", input$name, "!"))
  output$greeting <- renderText(string())
}
shinyApp(ui, server)
```


### Executation order
- Order Shiny code is run is solely determined by reactive graph (different from classic R code!)
- We could flip code in server function below
  - But keep order for easier understanding!

```{r 04-server-reactive-programming-8, echo=TRUE, eval=FALSE}
server <- function(input, output, session) {
  output$greeting <- renderText(string())
  string <- reactive(paste0("Hello ", input$name, "!"))
}
```


### Exercises
1. Can you spot errors in the code of the different `server1`, `server2` and `server3` below? 

```{r 04-server-reactive-programming-9, echo=TRUE, eval=FALSE}
# UI
ui <- fluidPage(
  textInput("name", "What's your name?"),
  textOutput("greeting")
)

# SERVERS
server1 <- function(input, output, server) {
  input$greeting <- renderText(paste0("Hello ", name))
}

server2 <- function(input, output, server) {
  greeting <- paste0("Hello ", input$name)
  output$greeting <- renderText(greeting)
}

server3 <- function(input, output, server) {
  output$greting <- paste0("Hello", input$name)
}



```



2.  Draw the reactive graph for the following three server functions:
```{r 04-server-reactive-programming-10}
server1 <- function(input, output, session) {
  c <- reactive(input$a + input$b)
  e <- reactive(c() + input$d)
  output$f <- renderText(e())
}

server2 <- function(input, output, session) {
  x <- reactive(input$x1 + input$x2 + input$x3)
  y <- reactive(input$y1 + input$y2)
  output$z <- renderText(x() / y())
}

server3 <- function(input, output, session) {
  d <- reactive(c() ^ input$d)
  a <- reactive(input$a * 10)
  c <- reactive(b() / input$c) 
  b <- reactive(a() + input$b)
}
```
    
    

## Reactive expressions (more!)
- [Chapter 3.4](https://mastering-shiny.org/basic-reactivity.html#reactive-expressions-1) is recommended reading!
- **Reactive expressions** (e.g., `reactive()`) are important because...
  - give Shiny more information so that it can do less recomputation when inputs change
  - make apps more efficient and easier for humans to understand (simplify reactive graph!)
- Are a like inputs since you can use results of a reactive expression in an output
- Are like outputs since they depend on inputs and automatically know when they need updating
- Helpful vocabulary
  - **Producers** refer to reactive inputs and expressions
  - **Consumers** refer to reactive expressions and outputs (@fig-prod-consumer)

```{r 04-server-reactive-programming-11, echo = FALSE, out.width = NULL}
#| label: fig-prod-consumer
#| fig-cap: "Inputs and expressions are reactive producers; expressions and outputs are reactive consumers (Source: Wickham 2021)"

knitr::include_graphics("resources/producers-consumers.png", dpi = 300)
```



## Varieties of reactive functions
- Various functions are relevant here, i.e., `reactive()`, `observeEvent()`,  `eventReactive()` and `bindevent()`

1. `reactive()`: used to create a reactive expression, which is a piece of code that can access reactive values (like inputs), do something with them, and return a value. A reactive expression is "reactive" in the sense that if its dependencies change, it will automatically update.

```r
tab <- reactive({
    var <- input$insp_select
    data_table <- guerry
    if (!is.null(var)) {data_table <- data_table[var]}
    data_table
  })
```

2. `observeEvent()` (observers): used when you want to perform an action in response to an event, but you don't need the result of the action to be used in the UI.
  - `observeEvent()` takes two arguments: `argument1` is what it should look for changes in; `argument2` is what it should do when it sees a change.

```r
observeEvent(input$goButton, {
  # this code runs whenever input$goButton changes
  some_function(input$var1)
})
```

3. `eventReactive()`: Similar to `reactive()`, but only re-evaluates when a certain event is triggered. It's a hybrid of `reactive()` and `observeEvent()`
  - `eventReactive()` takes two arguments: `argument1` is the event that triggers re-evaluation; `argument2` is the code to run when the event is triggered.

```r
result <- eventReactive(input$goButton, {
  # this code runs whenever input$goButton is clicked
  # value of result() will change only when input$goButton is clicked
  some_function(input$var1)
})
```

cked.

4. `isolate()`: used to access the value of a reactive expression or input without setting up a dependency
  - useful to access the current value of an input or reactive expression, but without re-running the code when that input or expression changes
  - Below the value of `input$n` is added to 1 and displayed when the "Go" button is clicked. But changes to `input$n` after the button is clicked do not affect the displayed result until the button is clicked again

```{r 04-server-reactive-programming-12, echo=TRUE, eval=FALSE}
# Shiny application
shinyApp(
  ui = fluidPage(
    numericInput("n", "Number to add:", 1),
    actionButton("goButton", "Go"),
    textOutput("result")
  ),
  server = function(input, output) {
    observeEvent(input$goButton, {
      output$result <- renderText({ isolate(input$n) + 1 }) 
    })
  }
)

```


4. `bindEvent()`: provides a straightforward API for event handling that wraps observe and isolate.

HIER WEITER

  - Use `bindEvent()` with `observe()` whenever you want to perform an action in response to an event.
    - `ignoreNULL` argument: affects behavior when the event expression evaluates to `NULL` (or in the special case of an `actionButton()`, 0). 
      - e.g., useful behavior if you don't want to do the action or calculation when your app first starts, but wait for the user to initiate the action first
    - `ignoreInit` argument: . By default, reactive expressions and observers will run on the first reactive flush after they are created (except if, at that moment, the event expression evaluates to NULL and ignoreNULL is TRUE). But when responding to a click of an action button, it may often be useful to set ignoreInit to TRUE. 
      - e.g., if you're setting up an observer to respond to a dynamically created button, then `ignoreInit = TRUE` will guarantee action will only be triggered when button is actually clicked, instead of also being triggered when it is created/initialized.

5. `reactiveTimer()`
  - a reactive expression that has a dependency on a hidden input: **the current time**
  - Use `reactiveTimer()` to invalidate a reactive expression itself more often than it otherwise would
  - See code example in [Chapter[3.5.1](https://mastering-shiny.org/basic-reactivity.html#timed-invalidation)


  - See discussion in [Chapter 3.5](https://mastering-shiny.org/basic-reactivity.html#controlling-timing-of-evaluation) for more background on these functions.





## Reactivity in our app
* Below we have some of the basic code underlying our app. How does reactivity work in this app and how would the reactive graph look like?


```{r 04-server-reactive-programming-13, cache=TRUE, eval=FALSE, include=TRUE, echo=FALSE}
library(shiny)
library(Guerry)
library(tidyverse)
library(sf)


## Data: Clean & prepare data ----
guerry <- Guerry::gfrance85 %>%
  st_as_sf() %>%
  as_tibble() %>%
  st_as_sf(crs = 27572) %>%
  mutate(Region = case_match(
    Region,
    "C" ~ "Central",
    "E" ~ "East",
    "N" ~ "North",
    "S" ~ "South",
    "W" ~ "West"
  )) %>%
  select(!any_of(c("CODE_DEPT", "COUNT", "AVE_ID_GEO", "dept"))) %>%
  st_drop_geometry() %>%
  select(1:6)


# UI ----

ui <- dashboardPage( # start UI
  title = "The Guerry Dashboard",
  
  ### Header ----
  header = dashboardHeader(
    title = tagList(
      img(src = "workshop-logo.png", width = 35, height = 35),
      span("The Guerry Dashboard", class = "brand-text")
    )
  ),
  
  ### Sidebar ----
  sidebar = dashboardSidebar(
    id = "sidebar",
    sidebarMenu(
      id = "sidebarMenu",
      menuItem(tabName = "tab_tabulate", 
               text = "Tabulate data", 
               icon = icon("table"))
    )
  ),
  ### Body ----
  body = dashboardBody(
    tabItems( # start tabItems
      
      tabItem(
        tabName = "tab_tabulate",
        fluidRow(
          pickerInput(
            "tab_tabulate_select",
            label = "Filter variables",
            choices = names(guerry),
            multiple = TRUE
          )
        ),
        hr(),
        #### Data table ----
        DT::dataTableOutput("tab_tabulate_table")
      )
      
    ) # end tabItems
  )
) # End UI



# Server ----

server <- function(input, output, session) {
  
  tab <- reactive({
    var <- input$tab_tabulate_select
    data_table <- guerry
    if (!is.null(var)) {data_table <- data_table[var]}
    data_table
  })
  
  
  ## Create table ----
  dt <- reactive({
    
    DT::datatable(
      tab(),
      class = "hover",
      selection = "none",
      filter = list(position = "top", clear = FALSE),
      rownames = FALSE
    )
    
  })
  
  ## Render table ----
  output$tab_tabulate_table <- DT::renderDataTable(dt(), server = FALSE)
  
}

shinyApp(ui, server)
```

## Reactlog: Visualizing reactivity
- Below we use `reactlog` to explore the reactivity of the app above
```{r 04-server-reactive-programming-14, cache=TRUE, eval=FALSE, include=TRUE, echo=FALSE}
# Restart R to delete log
.rs.restartR()

library(shiny)
library(reactlog)

# tell shiny to log all reactivity
reactlog_enable()
# reactlog_disable()

# run a shiny app
runApp("C:/Users/Paul/Google Drive/13_SHINY_Workshop/shinyapps/myfirstapp")

# once app has closed, display reactlog from shiny
shiny::reactlogShow()
```


## Tabulating data: Aggregation & saving


## Loading things in Shiny apps

### When is code run?
* When is code in a shiny app run? ([Source](https://shiny.posit.co/r/getstarted/shiny-basics/lesson5/#:~:text=Shiny%20will%20run%20code%20placed,the%20life%20of%20the%20app.))

![alt text](resources/run-once.png)
![alt text](resources/run-once-per-user.png)
![alt text](resources/run-many-times.png)

* Q: So where shall we put the function to load the dataset?
* Q: What problem might occur if we place certain code wrongly, e.g., load the data in the server or render function?





### Where to load things
* Code outside ```server <- function(input, output) {}``` is run once, when you launch your app
* Code inside ```server <- function(input, output) {}``` is run once each time a user visits your app
* Code inside ```render*``` functions is rerun constantly (not only when user changes widget value, see [reactivity(https://shiny.posit.co/r/articles/build/understanding-reactivity/)]) 
* That means...
    + Load **Source scripts, libraries, and data** outside of ```server``` function (at the beginning)
        + Store data in ```www/``` folder in your app directory
        + Access with ```read.table("www/swiss.csv", sep=",")```
        + Access online data by inserting the url into the ```read*``` function (e.g. ```read.table()```)
    + **User specific objects** (e.g. object that records user's session information) are defined inside shinyServer’s unnamed function, but outside of any render* calls
        + e.g. user registers himself, user data as input data (compare income)
    + **Code/objects that are affected by choices in widgets** must be placed within the a ```render*``` function
        + Shiny reruns code in a ```render*``` chunk each time a user changes a widget mentioned in the chunk
* **Avoid** placing code within render function that does not need to be there... for performance reasons!


## Data storage
- Things might get tricky for more data-hungry Shiny apps
- The way data is stored and accessed has some important implications for
    - Memory allocation: R stores objects in the working memory
    - Performance: "R does too much" - Colin Fay
    - Readability: Putting everything in one file might get messy
- For the Guerry app, I created a separate R code file which exports all the text elements into a JSON file:
 
```{r 04-server-reactive-programming-15, eval=FALSE, echo=TRUE}
library(jsonlite)
txts <- read_json("shinyapps/guerry/app_labels.json", simplifyVector = TRUE)
```
 
- For more sophisticated setups: **databases** (e.g., SQLite, PostgreSQL, MongoDB)
- R can work perfectly well with database connections (R Packages: DBI, dbplyr, sf)
- SQLite works well for casually trying out databases





## Summary

To build reactive shiny apps...

* Use `*Output` functions to place reactive objects in the UI (webpage)
* Use `render*` functions to let R build output objects (on the server)
    + Render functions are located in `server <- function(input, output) {...})` 
    + R expressions are surrounded by braces, `{}` in `render*` functions
    + Outputs of `render*` are saved in the `output` list, with one entry for each reactive object in your app
    + Reactivity by including an `input` values in a `render*` expression
* Often times you will adapt/modify [examples](http://shiny.rstudio.com/gallery/) that you find online



























