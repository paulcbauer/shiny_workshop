---
title: "Modelling and visualizing data"
---

```{r, include=FALSE}
library(dplyr)
library(ggplot2)
library(plotly)
library(htmltools)
library(listviewer)
library(htmlwidgets)
```


You will learn how to:

-   Implement and customize interactivity in plots
-   Leverage input events to fine-tune visualizations
-   Use proxies to update plots and maps on-the-fly (appendix)
-   Turn simple R plots into powerful Swiss knifes

## Interactive visualization: The core of Shiny

-   Shiny offers the perfect basis for visualization
    -   Plots can be modified using UI inputs
    -   Seamless integration of interactivity elements (e.g. pan, zoom)
    -   Dashboards facilitate the idea of story-telling by providing context to plots

### Good practice examples

-   Examples of these concepts can be seen in many Shiny apps, one example is Edward Parker's [COVID-19 tracker](https://vac-lshtm.shinyapps.io/ncov_tracker/)

::: callout-note
Exercise

Explore the COVID-19 tracker. Do you think this is a good Shiny app? If so, why? If not, why not?
:::

![COVID-19 Tracker](https://raw.githubusercontent.com/eparker12/nCoV_tracker/master/www/app_image.png)

### Plain plotting vs. Shiny

+---------------+--------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Feature       | Plain R                                                                              | Shiny                                                                                    | Examples                                                                   |
+===============+======================================================================================+==========================================================================================+============================================================================+
| Reactivity    | Changes in the visualization have to be changed in the code                          | Visualizations can be modified on the fly using widgets like drop-down menus             | [ExPanD](https://jgassen.shinyapps.io/expand_fuel_economy/)                |
+---------------+--------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Interactivity | Plots are static raster or vector images                                             | Plots can be dynamic and can be interacted with                                          | [COVID-19 tracker](https://vac-lshtm.shinyapps.io/ncov_tracker/)           |
+---------------+--------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Narrativity   | Sense-making happens through manual annotation, e.g. in an article or a presentation | Plots are embedded in a compilation of narrative elements that can tell a coherent story | [Freedom of Press Shiny app](https://johncoene.shinyapps.io/fopi-contest/) |
|               |                                                                                      |                                                                                          |                                                                            |
|               |                                                                                      |                                                                                          | [GRETA Analytics](https://projectgreta.shinyapps.io/greta-analytics/)      |
+---------------+--------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+

| Medium                   | Reactivity | Interactivity | Narrativity |
|--------------------------|------------|---------------|-------------|
| Plain image              | ❌         | ❌            | ❌          |
| Paper / report           | ❌         | ❌            | ✅          |
| Dashboard (e.g. Tableau) | ❌         | ☑️            | ✅          |
| Quarto / RMarkdown       | ❌         | ☑️            | ✅          |
| Traditional website      | ☑️         | ✅            | ✅          |
| Shiny                    | ✅         | ✅            | ✅          |

### Current app state

-   In the last sections, we added a table and a plot and linked them to a number of inputs
-   The code chunk below contains the current app state
-   In this section, we will:
    -   Augment the violin plot
    -   Add an interactive map

```{r test, eval=FALSE, file="shinyapps/example/states/06-base.R"}
#| code-fold: true
#| code-summary: Full code for the current app state
```

### Recap: Plotting in Shiny

-   Inserting plots in Shiny apps works just like any other UI component
-   You need two things: `plotOutput()` (or similar) in the UI and `renderPlot()` (or similar) in the server function
    -   [`plotOutput()`](https://shiny.posit.co/r/reference/shiny/1.7.4/plotoutput) creates the empty element in the UI where the plot will go
    -   [`renderPlot()`](https://shiny.posit.co/r/reference/shiny/1.7.4/renderplot) renders the plot and updates the UI element every time a reactive dependency is invalidated

## Interactivity

-   R itself is *very bad* at interactivity
-   Shiny supports some very essential interactivity through `plotOutput`
    -   Not covered in this workshop! For a primer, check out [chapter 7.1](https://mastering-shiny.org/action-graphics.html#interactivity) of Mastering Shiny
-   All of today's cool kids use interactivity through Javascript interfaces

### Popular Javascript interfaces

-   Examples of Javascript libraries and their corresponding R packages
    -   [Plotly](https://plotly-r.com/) (covered here)
    -   [Leaflet](https://rstudio.github.io/leaflet/) (covered here)
    -   [Highcharts](https://jkunst.com/highcharter/)
    -   [Bokeh](https://hafen.github.io/rbokeh/index.html)
    -   [D3](https://rstudio.github.io/r2d3/index.html)
    -   [Apache ECharts](https://echarts4r.john-coene.com/)
    -   [Frappe Charts](https://merlinoa.github.io/rfrappe/)
    -   [billboard.js](https://dreamrs.github.io/billboarder/)
    -   [apexcharts.js](https://dreamrs.github.io/apexcharter/)
    -   [Google Charts](https://mages.github.io/googleVis/)
    -   [amCharts 4](https://doi.org/10.32614/CRAN.package.rAmCharts4)
    -   [Deck.gl](https://symbolixau.github.io/mapdeck/articles/mapdeck.html)
    -   [WebGL](https://dmurdoch.github.io/rgl/index.html)

## Plotly

- Plotly is an open-source library to create charts that can be interacted with in various way
- It supports several languages including R and Python
- Plotly is arguably the most renowned R package for interactive plotting
- It even motivated an entire book: <https://plotly-r.com/>

### Plotly's grammar of graphics

-   Similar to ggplot2, R plotly defines its own grammar of graphics
-   A plotly canvas is created with `plot_ly()`
-   Additional plot elements can be added through pipes `%>%` or `|>`

```{r}
mtcars$am[which(mtcars$am == 0)] <- 'Automatic'
mtcars$am[which(mtcars$am == 1)] <- 'Manual'
mtcars$am <- as.factor(mtcars$am)


plot_ly(
  mtcars,
  x = ~wt, # <1>
  y = ~hp, # <1>
  z = ~qsec, # <1>
  color = ~am, # <1>
  colors = c('#BF382A', '#0C4B8E')
) %>%
  add_markers() %>% # <2>
  layout(scene = list( # <3>
    xaxis = list(title = 'Weight'), # <3>
    yaxis = list(title = 'Gross horsepower'), # <3>
    zaxis = list(title = '1/4 mile time') # <3>
  )) # <3>
```

1.  Variables such as x, y, z and color are defined as formulas in a call to `plot_ly`. This is comparable to calling `ggplot(aes(x, y, z, color))`.
2.  The plot type is added through a pipe. This is comparable to `ggplot2` functions such as `geom_point` or `geom_bar`.
3.  Visual sugar is then added by calling `layout` and manually editing the axis titles.

### Quick and dirty interactivity

-   One important advantage of plotly is that you do not need to learn its grammar
-   `ggplot2` plots can very easily be converted to an interactive plotly plot:

```{r}
p <- ggplot(iris) +
  geom_point(aes(Sepal.Width, Sepal.Length))
p
```

```{r}
ggplotly(p)
```

### Extending plotly

#### Customization

-   We can extend Plotly objects using three functions:
    -   `layout()` changes the plot organisation (think [`ggplot2::theme()`](https://ggplot2.tidyverse.org/reference/theme.html)), e.g.:
        -   colors, sizes, fonts, positions, titles, ratios and alignment of all kinds of plot elements
        -   `updatemenus` adds buttons or drop down menus that can change the plot style or layout (see [here](https://plotly.com/r/dropdowns/) for examples)
        -   `sliders` adds sliders that can be useful for time series (see [here](https://plotly.com/r/sliders/) for examples)
    -   `config()` changes interactivity configurations, e.g.:
        -   The `modeBarButtons` options and `displaylogo` control the buttons in the mode bar
        -   `toImageButtonOptions` controls the format of plot downloads
        -   `scrollZoom` enables or disables zooming by scrolling
    -   `style()` changes data-level attributes (think [`ggplot2::scale_`](https://ggplot2.tidyverse.org/reference/#scales)), e.g.:
        -   `hoverinfo` controls whether tooltips are shown on hover
        -   `mode` controls whether to show points, lines and/or text in a scatter plot
        -   `hovertext` modifies the tooltips texts shown on hover

#### Schema

-   The actual number of options is immense!
-   You can explore all options by calling [`plotly::schema()`](https://rdrr.io/cran/plotly/man/schema.html)

```{r eval=FALSE}
schema()
```

```{r echo=FALSE}
sch <- jsonedit(plotly:::Schema, mode = "form")
path <- file.path(getwd(), "schema.html")
saveWidget(sch, path)
tags$iframe(srcdoc = paste(readLines(path), collapse = '\n'), width = "100%", height = 500)
```

```{r echo=FALSE}
unlink(path)
```

#### Example

```{r}
p <- ggplot(iris) +
  geom_point(aes(Sepal.Width, Sepal.Length))

ggplotly(p) %>%
  config(
    modeBarButtonsToRemove = c( # <1>
      "sendDataToCloud", "zoom2d", "select2d", "lasso2d", "autoScale2d", # <1>
      "hoverClosestCartesian", "hoverCompareCartesian", "resetScale2d" # <1>
    ), # <1>

    displaylogo = FALSE, # <2>

    toImageButtonOptions = list( # <3>
      format = "svg", # <3>
      filename = "plot", # <3>
      height = NULL, # <3>
      width = NULL # <3>
    ), # <3>

    scrollZoom = TRUE # <4>
  )
```

1.  Removes specified buttons from the modebar.
2.  Removes the Plotly logo.
3.  Changes the output of snapshots taken of the plot. Setting `height` and `width` to `NULL` keeps the aspect ratio of the plot as it is shown in the app.
4.  Enables zooming through scrolling.

### Plotly and Shiny

-   Since plotly does not produce static plots like `ggplot2`, it cannot be served by `plotOutput` and `renderPlot`
-   Plotly defines two new functions:
    -   `plotlyOutput` on the UI side
    -   `renderPlotly` on the server side

UI:

```{r, eval=FALSE}
#| source-line-numbers: "17"
mainPanel(
  tabsetPanel(
    type = "tabs",
    
    ### Table tab ----
    tabPanel(
      title = "Table",
      div(
        style = "height: 600px; overflow-y: auto;",
        tableOutput("table")
      )
    ),
    
    ### Plot tab ----
    tabPanel(
      title = "Histogram",
      plotlyOutput("plot", height = 600)
    )
  )
)
```

Server:

```{r, eval=FALSE}
#| source-line-numbers: "8,12"
output$plot <- renderPlotly({
  xvar <- input$xvar
  yvar <- input$yvar
  plot_data <- filtered() %>%
    drop_na() %>%
    mutate(across(where(is.numeric), .fns = as.ordered))
  
  p <- ggplot(plot_data) +
    aes(x = .data[[xvar]], y = .data[[yvar]], group = .data[[xvar]]) +
    geom_violin(fill = "lightblue", show.legend = FALSE) +
    theme_classic()
  ggplotly(p)
})
```

```{r, eval=FALSE, file="shinyapps/example/states/06-plotly.R"}
#| code-fold: true
#| code-summary: "Complete code (important lines are highlighted)"
#| source-line-numbers: "83,146,150"
```



Exercises

::: callout-note
Exercise 1

Thinking back to our initial visualization structure (data selection, data exploration, data modelling, ???), what could be a good last step? What type of visualization can enhance our understanding of the relationship among the Guerry variables? Write down your ideas along with possible types of visualizations.
:::

::: {.callout-tip collapse="true"}
Visit the [R graph gallery](https://r-graph-gallery.com/) or the [R Plotly gallery](https://plotly.com/r/) to get inspired!
:::

::: callout-note
Exercise 2

Add a fourth quadrant in the dashboard layout. Also add a box that will hold the content.
:::

::: {.callout-tip collapse="true"}
Don't forget about the use of `fluidRow()` and `column()`! The new quadrant goes right below the pair plot in the second column:

```{r eval=FALSE}
fluidRow(
	column(
		width = 6,
		box(width = 12), # quadrant 1
		box(width = 12) # quadrant 3
	),
	column(
		width = 6,
		box(width = 12), # quadrant 2
		box(width = 12) # quadrant 4
	)
)
```
:::

::: {.callout-warning collapse="true"}
Solution

The fourth quadrant is the second row of the second column, i.e.:

```{r eval=FALSE}
fluidRow(
	column(
		width = 6,
		box(width = 12), # quadrant 1
		box(width = 12) # quadrant 3
	),
	column(
		width = 6,
		box(width = 12), # quadrant 2
		box(width = 12, status = "primary", plotOutput("new_plot")) # quadrant 4
	)
)
```
:::

::: callout-note
Exercise 3

Add a UI output and an empty rendering function
:::

::: {.callout-tip collapse="true"}
The respective plotly functions are `plotly::plotlyOutput()` and `plotly::renderPlotly()`
:::

::: callout-note
Exercise 4

Implement the visualization from exercise 1 within the new box from exercise 2. Create your plot using ggplot2 and convert it to a plotly chart using `ggplotly()`
:::

::: callout-note
Exercise 5

Remove all mode bar buttons except "Zoom in" and "Zoom out" from the new visualization of exercise 4
:::

::: {.callout-tip collapse="true"}
The relevant function is `plotly::config()`

Call `schema()` and explore `object -> config` to find out about ways to remove mode bar buttons

A list of modebar buttons is provided on Plotly's [GitHub repository](https://github.com/plotly/plotly.js/blob/master/src/components/modebar/buttons.js) or under `object -> layout -> layoutAttributes -> modebar -> remove`
:::

::: {.callout-warning collapse="true"}
Solution

To remove modebar buttons, we need to change the `plotly::config()` of the generated plot output:

```{r eval=FALSE}
ggplotly(p) %>%
  config(modeBarButtonsToRemove = c(
    "sendDataToCloud", "zoom2d", "select2d", "lasso2d", "autoScale2d", "toimage",
    "hoverClosestCartesian", "hoverCompareCartesian", "resetScale2d", "pan"
))
```
:::

::: callout-note
Exercise 6

Change the axis width of the new graph from exercise 4 to 5 pixels and color to #000
:::

::: {.callout-note collapse="true"}
The relevant function is `plotly::layout()`

Call `schema()` and explore `object -> layout -> layoutAttributes` to find out about ways to change the axis layout
:::

::: {.callout-warning collapse="true"}
Solution

To change the axis width, we need to change the `plotly::layout()` of the plotly object. Determining which option controls the axis layout is a tricky question. To do that, we can explore the `plotly::schema()`. In this case, the relevant option is found unter `object -> layout -> layoutAttributes -> xaxis/yaxis -> linewidth/linecolor`. Then, just add a layout to the plot object and change the relevant options:

```{r eval=FALSE}
ggplotly(p) %>%
	layout(
	  xaxis = list(linewidth = 5, linecolor = "#000"),
	  yaxis = list(linewidth = 5, linecolor = "#000")
	)
```
:::

::: callout-note
Exercise 7

Currently, we have three input widgets to change the appearance of plots: `model_x`, `model_y`, and `model_std`. Implement another input widget that allows users to manipulate the data, output or the plot appearance.
:::

::: {.callout-tip collapse="true"}
Should the new input widget change all plots or just a selection of plots? Should the new widgets control the way data is cleaned (e.g. normalising), analysed (e.g. different modelling approaches) or displayed (e.g. plot theming)?
:::
