---
title: "Mapping data & advanced visualization"
---

```{r include=FALSE}
pacman::p_load(
	shiny,
	htmltools,
	bs4Dash,
	fresh,
	waiter,
	shinyWidgets,
	Guerry,
	sf,
	tidyr,
	dplyr,
	RColorBrewer,
	viridis,
	leaflet,
	plotly,
	jsonlite
)

guerry <- Guerry::gfrance85 %>%
  st_as_sf() %>% # convert sp to the newer sf format
  as_tibble() %>%
  st_as_sf(crs = 27572) %>% # set the correct coordinate reference system
  mutate(Region = case_match(
    Region,
    "C" ~ "Central",
    "E" ~ "East",
    "N" ~ "North",
    "S" ~ "South",
    "W" ~ "West"
  ))

variables <- guerry %>%
  st_drop_geometry() %>%
  select(where(is.numeric) & !all_of(c("COUNT", "dept", "AVE_ID_GEO"))) %>%
  names()

guerry_region <- guerry %>%
  group_by(Region) %>%
  summarise(across(
  .cols = all_of(variables),
  function(x) {
    if (cur_column() %in% c("Area", "Pop1831")) {
      sum(x)
    } else {
      mean(x)
    }
  }
 ))
  
txts <- read_json("shinyapps/guerry/app_labels.json", simplifyVector = TRUE)
```

## Learning outcomes

You will learn how to:

-   Work with spatial data

-   Create interactive maps in Shiny using Leaflet

-   Use Shiny events and proxies

## Interactive maps

-   Mapping is a type of data visualization based on *spatial data*

-   Classic cartography relies on generalization and interpretation

-   Interactive cartography removes many limitations such as generalization and map boundaries

![Generalization in OpenStreetMap at different scales](resources/generalization.gif)

-   Further resources:

    -   [Chapter 9](https://r.geocompx.org/adv-map.html) of Robin Lovelace's "Geocomputation with R"

    -   The documentation of [Leaflet for R](https://rstudio.github.io/leaflet/)

## The basics

-   Spatial data is the foundation of mapping, but what is it?

-   Spatial data is all data that can be explicitly linked to a spatial reference (longitude/latitude)

### Types of spatial data

-   Geography can describe the world in two ways:

    -   As spatially continuous processes (or as *raster data*)

    -   As an ensemble of individual elements (or as *vector data*)

-   Vector data is also called spatial geometries and can be divided into

    -   Points (e.g., individual events or places)

    -   Lines (e.g., streets, rivers)

    -   Polygons (e.g., buildings, districts)

![The real world described by layers of raster and vector data ([Source](https://saylordotorg.github.io/text_essentials-of-geographic-information-systems/s11-02-multiple-layer-analysis.html#campbell_1.0-ch07_s02_f01))](https://saylordotorg.github.io/text_essentials-of-geographic-information-systems/section_11/ca6ce94cdd2e09a1da8aa6ec22336835.jpg){width="440"}

### Spatial data in R

-   In R, spatial data can be handled using various packages:

    -   `sp` (vector data) and `raster` (raster data) used to be the common packages for spatial analysis

    -   `sf` (vector data) and `terra` (raster data) are their more timely successors

-   By default, `guerry` is an sp object, but we converted it to an sf dataframe

-   `sf` dataframes consist of a geometry column (class `sfc`) and multiple features (i.e. non-spatial columns)

-   `sfc` geometries are list-like objects that consist of individual geometries (class `sfg`) and spatial metadata (e.g. type or dimension)

-   `sfg` objects are matrices consisting purely of coordinates

```{r}
st_sf( # create an sf dataframe
	feature = c(1, 2), # feature column
	geometry = # geometry column
		st_sfc( # sfc object = geometry + spatial metadata
			st_point(c(1, 1)), # sfg object = raw geometry
			st_point(c(1, 2)), 
		  st_point(c(2, 2)),
			st_point(c(2, 1))
		)
)
```

### Coordinate reference systems

-   All spatial data need to have a **coordinate reference system** (CRS) that locates the coordinates on the planet

-   The geodetic specifics are mostly not necessary, but it's always good to know a basic distinction

    -   **Geodetic CRS**

        -   Uses angular units (degrees) because they are based on a spheroid

        -   Usually good for global or national scale visualizations

        -   Example: WGS84 (World Geodetic System)

    -   **Projected CRS**

        -   Uses metric units (meters) because they are based on a projected model of the earth

        -   Usually good for local or regional high-precision spatial analysis and visualization

        -   Example: UTM (Universal Transversal Mercator)

![UTM (Universal Transversal Mercator) - a projected coordinate system. Each zone is a CRS.](https://upload.wikimedia.org/wikipedia/commons/e/ed/Utm-zones.jpg)

### EPSG codes

-   CRS can be referenced using numeric identifiers called EPSG codes

    -   EPSG database: <https://epsg.io/>, e.g. EPSG code 4326: <https://epsg.io/4326>

| Name                                                                                      | EPSG code | Area           | Geodetic? | Use                                                       |
|--------------------------|-----------|-----------|-----------|---------------|
| [World Geodetic System 1984 (WGS84)](https://en.wikipedia.org/wiki/World_Geodetic_System) | 4326      | World          | Yes       | Basic geographic coordinates, common usage in GPS systems |
| [WGS 84 / Pseudo-Mercator](https://en.wikipedia.org/wiki/Web_Mercator_projection)         | 3857      | World          | No        | Google Maps, OpenStreetMap, general web mapping           |
| [UTM zone 32N](https://de.wikipedia.org/wiki/UTM-Koordinatensystem)                       | 25832     | Central Europe | No        | Spatial analysis and measuring in Central Europe          |
| [LAEA Europe](https://en.wikipedia.org/wiki/European_grid)                                | 3035      | Europe         | No        | Multi-purpose CRS developed by the EU                     |

: Some common CRS

### CRS in R

-   How do we work with CRS in R?

    -   Convert to an sf dataframe: [`st_as_sf`](https://r-spatial.github.io/sf/reference/st_as_sf.html)`(..., crs = 4326)`

    -   Assign a CRS to an existing sf dataframe: [`st_crs`](https://r-spatial.github.io/sf/reference/st_crs.html)`(...) <- 4326` or `st_set_crs(â€¦, 4326)`

    -   Transform an existing CRS to a new CRS: [`st_transform`](https://r-spatial.github.io/sf/reference/st_transform.html)`(..., 4326)`

<!-- -->

-   **Question:** What can we say about the Guerry dataset in terms of spatial information?

```{r}
guerry["Literacy"]
```

## Interactive maps using Leaflet

-   R offers many solutions to mapping, some more advanced than others

    -   [`ggplot2`](https://cloud.r-project.org/web/packages/ggplot2/) supports spatial data with functions like [`geom_sf`](https://ggplot2.tidyverse.org/reference/ggsf.html), [`coord_sf`](https://ggplot2.tidyverse.org/reference/ggsf.html) and custom ones like [`stars::geom_stars`](https://r-spatial.github.io/stars/reference/geom_stars.html)

    -   [`tmap`](https://cran.r-project.org/web/packages/tmap/) is a comprehensive framework for high-quality thematic mapping

    -   [`cartography`](https://cran.r-project.org/web/packages/cartography/index.html) and [`mapsf`](https://cran.r-project.org/web/packages/mapsf/index.html) incorporate cartography principles to move R closer to dedicated mapping software

    -   [`leaflet`](https://cran.r-project.org/web/packages/leaflet/) interfaces the Leaflet JavaScript library to create interactive map visualizations

### Integrate Leaflet in Shiny

-   Leaflet in Shiny works just like any other type of visualization, we need:

    -   A UI output: [`leaflet::leafletOutput()`](https://rdrr.io/cran/leaflet/man/map-shiny.html)

    -   A rendering function: [`leaflet::renderLeaflet()`](https://rdrr.io/cran/leaflet/man/map-shiny.html)

-   In our app, we add a geographic explorer of the Guerry dataset

```{r eval=FALSE}
tabItem(
  tabName = "exp", # must correspond to related menuItem name
  fluidRow(
    column(
      width = 12,
      box(
        id = "exp_box",
        status = "primary",
        headerBorder = FALSE,
        collapsible = FALSE,
        width = 12,
        leaflet::leafletOutput("exp_map", height = "800px", width = "100%")
      ) # end box
    ) # end column
  ) # end fluidRow
) # end tabItem
```

### Leaflet workhorse

-   The leaflet package is centered around the workhorse [`leaflet()`](https://rdrr.io/cran/leaflet/man/leaflet.html) which creates an empty map canvas

-   Each additional function can be piped into and adds an additional mapping component (similar to `ggplot2`)

    -   [`addProviderTiles()`](https://rdrr.io/cran/leaflet/man/addProviderTiles.html) adds a base map, in this case we use four base maps that can be chosen from

    -   [`addLayersControl()`](https://rdrr.io/cran/leaflet/man/addLayersControl.html) adds a button that lets you switch between map layers

    -   [`setView()`](https://rdrr.io/cran/leaflet/man/map-methods.html) sets the center and zoom level of the initial map view

```{r eval=FALSE}
output$exp_map <- leaflet::renderLeaflet({
		leaflet() %>%
			addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
			addProviderTiles("OpenTopoMap", group = "OTM") %>%
			addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
			addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
			addLayersControl(baseGroups = c("OSM", "OTM",
																			"Stamen Toner", "Orthophotos")) %>%
			setView(lng = 3, lat = 47, zoom = 5)
})
```

![](resources/06_01.gif)

## Add data

-   Currently, we only show a background, but do not map the Guerry data

-   Adding data works using layer functions, for example:

    -   [`addMarkers()`](https://rdrr.io/cran/leaflet/man/map-layers.html) adds point data

    -   [`addPolylines()`](https://rdrr.io/cran/leaflet/man/map-layers.html) adds line data

    -   [`addPolygons()`](https://rdrr.io/cran/leaflet/man/map-layers.html) adds polygon data

    -   [`addRasterImage()`](https://rdrr.io/cran/leaflet/man/addRasterImage.html) adds raster data

    -   [`addLegend()`](https://rdrr.io/cran/leaflet/man/addLegend.html) adds a legend

### Specifics of Leaflet mapping

-   Variables are passed using formulas (i.e. instead of `guerry$Literacy`, we write `~Literacy`)

-   Leaflet by default only supports WGS84 (EPSG:4326) as CRS

-   Palettes are applied using custom functions that are generated in function factories:

    -   `colorNumeric()` maps continuous values

    -   `colorBin()` bins continuous values evenly

    -   `colorQuantile()` bins continuous values based on their quantiles

    -   `colorFactor()` maps categorical values

-   `highlightOptions()` adds a nice highlight effect when hovering over a polygon

```{r eval=FALSE}
# Compile parameters for leaflet rendering
params <- reactive({
	values <- ~Literacy # passing data works using formulas
	pal <- colorNumeric(palette = "Reds", domain = NULL)
	
	list(
		var = var,
		pal = pal
	)
})

output$exp_map <- leaflet::renderLeaflet({
	# Isolate call to params() to prevent render function to be executed
	# every time params() is invalidated. No dependency is made.
	params <- params()
	leaflet(data = st_transform(guerry, 4326)) %>%
		addProviderTiles("OpenStreetMap.France") %>%
		setView(lng = 3, lat = 47, zoom = 5) %>%
		addPolygons(
			fillColor = ~params$pal(Literacy),
			fillOpacity = 0.7,
			weight = 1,
			color = "black",
			opacity = 0.5,
			highlightOptions = highlightOptions( # add highlighting on hover
				weight = 2,
				color = "black",
				opacity = 0.5,
				fillOpacity = 1,
				bringToFront = TRUE,
				sendToBack = TRUE
			)
		) %>%
		addLegend(
			position = "bottomright",
			pal = params$pal,
			values = params$values,
			opacity = 0.9,
			title = "Literacy",
			labFormat = labelFormat(suffix = " %")
		)
})
```

![](resources/06_02.gif)

## Add reactivity

-   Similar to chapter 5 on visualization, reactivity is the key to making maps in Shiny

-   Similar to chapter 5, reactivity is arguably the most complex part of app development!

### Reactive UI

-   In our app, we add three reactive components:

    -   `selectInput()` to select a variable to map

    -   `radioButtons()` to select an aggregation level, departments or regions

    -   `selectInput()` to select a color palette

-   Additionally, one new UI output (`exp_desc`) is added that describes the selected variable

```{r}
# Define selectable palettes: All sequential palettes + viridis
pals <- list(
  Sequential = RColorBrewer::brewer.pal.info %>%
    filter(category %in% "seq") %>%
    row.names(),
  Viridis = c("Magma", "Inferno", "Plasma", "Viridis",
              "Cividis", "Rocket", "Mako", "Turbo")
)
```

```{r eval=FALSE}
# Define new tab item: "exp"
tabItem(
	tabName = "exp", # must correspond to related menuItem name
	fluidRow(
		column(
			width = 4, # must be between 1 and 12
			box(
				title = "Data selection",
				status = "primary",
				width = 12,
				selectInput(
					"exp_select",
					label = "Select a variable",
					choices = setNames(variables, sapply(txts, "[[", "title"))
				),
				uiOutput("exp_desc")
			),
			box(
				title = "Map configuration",
				status = "primary",
				width = 12,
				radioButtons(
					"exp_aggr",
					label = "Aggregation level",
					choices = c("Departments", "Regions"),
					selected = "Departments"
				),
				selectInput(
					"exp_pal",
					label = "Color palette",
					choices = pals,
					selected = "Reds"
				) # end input
			) # end box
		), # end column
		column(
			width = 8,
			box(
				id = "exp_box",
				status = "primary",
				headerBorder = FALSE,
				collapsible = FALSE,
				width = 12,
				leaflet::leafletOutput("exp_map", height = "800px", width = "100%")
			) # end box
		) # end column
	) # end fluidRow
) # end tabItem
```

### Spatial operations

-   To change the aggregation level, we need the Guerry dataset at different levels

-   The Guerry dataset contains two group variables: Department (smaller) and Region (larger)

-   We perform spatial aggregation on the Guerry dataset *outside* of the server function:

```{r}
# Extract variable names
variables <- guerry %>%
	st_drop_geometry() %>%
	select(where(is.numeric) & !all_of(c("COUNT", "dept", "AVE_ID_GEO"))) %>%
	names()

## Aggregate ----
guerry_region <- guerry %>%
	group_by(Region) %>%
	summarise(across(
		.cols = all_of(variables),
		function(x) {
			if (cur_column() %in% c("Area", "Pop1831")) {
				sum(x)
			} else {
				mean(x)
			}
		}
	))
```

### Server side

-   In the server function, we have a lot to do (annotated with their respective letters in the code below):

    -   Render a description for the selected variable (A)

    -   Apply the selected aggregation level (B)

    -   Apply the selected palette (C)

    -   Change hard code to adaptive code (D)

```{r eval=FALSE}
	## Explore data ----
	
	# Render description of selected variable (A)
	output$exp_desc <- renderUI({
		HTML(txts[[input$exp_select]]$desc)
	})
	
	# Select polygon based on aggregation level (B)
	poly <- reactive({
		if (identical(input$exp_aggr, "Regions")) {
			guerry_region
		} else {
			guerry
		}
	})
	
	# Select palette based on input (C)
	palette <- reactive({
		pal <- input$exp_pal
		if (pal %in% pals$Viridis) {
			pal <- viridis::viridis_pal(option = tolower(pal))(5)
		}
		pal
	})
	
	# Compile parameters for leaflet rendering (D)
	params <- reactive({
		poly <- st_transform(poly(), 4326)
		pal <- palette()
		var <- input$exp_select
		
		values <- as.formula(paste0("~", var))
		pal <- colorNumeric(palette = pal, domain = NULL)
		
		list(
			poly = poly,
			var = var,
			pal = pal,
			values = values,
			labels = labels
		)
	})
	
	# Render leaflet for the first time
	output$exp_map <- leaflet::renderLeaflet({
		# Isolate call to params() to prevent render function to be executed
		# every time params() is invalidated. No dependency is made.
		params <- params()
		leaflet(data = params$poly) %>%
			addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
			addProviderTiles("OpenTopoMap", group = "OTM") %>%
			addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
			addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
			addLayersControl(baseGroups = c("OSM", "OTM",
																			"Stamen Toner", "Orthophotos")) %>%
			setView(lng = 3, lat = 47, zoom = 5) %>%
			addPolygons(
				fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
				fillOpacity = 0.7,
				weight = 1,
				color = "black",
				opacity = 0.5,
				highlightOptions = highlightOptions(
					weight = 2,
					color = "black",
					opacity = 0.5,
					fillOpacity = 1,
					bringToFront = TRUE,
					sendToBack = TRUE
				)
			) %>%
			addLegend(
				position = "bottomright",
				pal = params$pal,
				values = params$values,
				opacity = 0.9,
				title = txts[[params$var]]$lgd,
				labFormat = labelFormat(suffix = txts[[params$var]]$unit)
			)
	})
```

![](resources/06_03.gif)

## Add hover labels

-   Unlike Plotly, Leaflet does not automatically provide labels for data points

    -   Bad news: You have to do it on your own :(

    -   Good news: You have more freedom in designing hover labels :)

### How to add labels

-   Adding labels is itself not a difficult task: You can just provide the values vector we use as data input:

```{r eval=FALSE}
leaflet() %>%
	addPolygons(
		..., # rest of the args
		label = ~values
	)
```

### Advanced label layout using HTML

-   This is *enough*, but not very pretty and it doesn't provide potentially important metadata like region names

-   In our app, we use a table layout containing information about region, department and variable value

-   You can create generic HTML tables using the `table` tag (`tags$table`) together with the `tr` (table row, `tags$tr`) and `td` (table data, `tags$td`)

```{r}
tags$table(
	tags$tr(
		tags$td("Cell 1"),
		tags$td("Cell 2"),
		tags$td("Cell 3")
	),
		tags$tr(
		tags$td("Cell 4"),
		tags$td("Cell 5"),
		tags$td("Cell 6")
	),
		tags$tr(
		tags$td("Cell 7"),
		tags$td("Cell 8"),
		tags$td("Cell 9")
	)
)
```

![](https://vertex-academy.com/tutorials/wp-content/uploads/2016/08/table.png)

```{r eval=FALSE}
params <- reactive({
  poly <- st_transform(poly(), 4326)
  pal <- palette()
  var <- input$exp_select

  values <- as.formula(paste0("~", var))
  pal <- colorNumeric(palette = pal, domain = NULL)
  
  reg <- poly[["Region"]]
  dep <- poly[["Department"]]
  val <- poly[[var]]
  
  # If aggregated on region level, department will be NULL
  if (is.null(dep)) {
    dep <- rep(NA, nrow(poly))
  }

  # Create labels that are nicely aligned in a grid
  # If aggregated on region level, omit department name (because it is NULL)
  labels <- mapply(
    function(reg, dep, val) {
      HTML(as.character(tags$table(
      	# Add region row
        tags$tr(
          style = "line-height: 10px", # more compact layout
          tags$td(tags$b("Region: ")), # left-hand side
          tags$td(reg) # right-hand side
        ),
        # Add department row if available
        if (!is.na(dep)) {
          tags$tr(
            style = "line-height: 10px",
            tags$td(tags$b("Department: ")),
            tags$td(dep)
          )
        },
        # Add value row
        tags$tr(
          style = "line-height: 10px",
          tags$td(tags$b(paste0(txts[[var]]$lgd, ": "))),
          tags$td(round(val, 2))
        )
      )))
    },
    reg = reg, dep = dep, val = val,
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE
  )

  list(
    poly = poly,
    var = var,
    pal = pal,
    values = values,
    labels = labels
  )
  
  # Render leaflet for the first time
  output$exp_map <- leaflet::renderLeaflet({
    # Isolate call to params() to prevent render function to be executed
    # every time params() is invalidated. No dependency is made.
    params <- isolate(params())
    leaflet(data = params$poly) %>%
      addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
      addProviderTiles("OpenTopoMap", group = "OTM") %>%
      addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
      addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
      addLayersControl(baseGroups = c("OSM", "OTM",
                                      "Stamen Toner", "Orthophotos")) %>%
      setView(lng = 3, lat = 47, zoom = 5) %>%
      addPolygons(
        fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
        fillOpacity = 0.7,
        weight = 1,
        color = "black",
        opacity = 0.5,
        label = params$labels, # don't forget to pass the labels to the map!!
        highlightOptions = highlightOptions(
          weight = 2,
          color = "black",
          opacity = 0.5,
          fillOpacity = 1,
          bringToFront = TRUE,
          sendToBack = TRUE
        )
      ) %>%
      addLegend(
        position = "bottomright",
        pal = params$pal,
        values = params$values,
        opacity = 0.9,
        title = txts[[params$var]]$lgd,
        labFormat = labelFormat(suffix = txts[[params$var]]$unit)
      )
  })
})
```

![](resources/06_04.gif)

## Add proxies

-   The map already looks quite polished!

-   One more problem: Map updates!

-   Map re-renders every time an input is invalidated:

    -   Everything needs to be redrawn = slow for large datasets

    -   Map view resets with every update:

![](resources/06_05.gif)

### What are proxies?

-   Solution: Proxies

-   Proxy objects are representations of existing widgets that can manipulate widgets in place

### Proxies in Shiny extensions

-   Many Shiny extensions provide proxy functions:

    -   [`DT::dataTableProxy()`](https://rdrr.io/cran/DT/man/proxy.html)

    -   [`plotly::plotlyProxy()`](https://rdrr.io/cran/plotly/man/plotlyProxy.html)

    -   [`leaflet::leafletProxy()`](https://rdrr.io/cran/leaflet/man/leafletProxy.html)

### Proxy workflow

1.  Initialize an isolated output widget (i.e., no dependencies)

2.  Create an observer that updates input dependencies

3.  Invalidate an input

4.  Remove existing features and add new ones

![Reactive graph for proxies](resources/proxies.svg)

### Isolate reactive objects

-   To create an isolated output widget, we use the `isolate()` function from Shiny

    -   The `params()` reactive is executed only *once*, but does take a dependency

```{r eval=FALSE}
  # Render leaflet for the first time
  output$exp_map <- leaflet::renderLeaflet({
    # Isolate call to params() to prevent render function to be executed
    # every time params() is invalidated. No dependency is made.
    params <- isolate(params())
    leaflet(data = params$poly) %>%
      addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
      addProviderTiles("OpenTopoMap", group = "OTM") %>%
      addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
      addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
      addLayersControl(baseGroups = c("OSM", "OTM",
                                      "Stamen Toner", "Orthophotos")) %>%
      setView(lng = 3, lat = 47, zoom = 5) %>%
      addPolygons(
        fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
        fillOpacity = 0.7,
        weight = 1,
        color = "black",
        opacity = 0.5,
        label = params$labels,
        highlightOptions = highlightOptions(
          weight = 2,
          color = "black",
          opacity = 0.5,
          fillOpacity = 1,
          bringToFront = TRUE,
          sendToBack = TRUE
        )
      ) %>%
      addLegend(
        position = "bottomright",
        pal = params$pal,
        values = params$values,
        opacity = 0.9,
        title = txts[[params$var]]$lgd,
        labFormat = labelFormat(suffix = txts[[params$var]]$unit)
      )
  })
```

### Implement proxies

-   Instead, we create an observer that updates the map layers *in place*

-   First, all existing features that are to be changed are cleared

-   Second, new features are added in the usual piping manner

```{r eval=FALSE}
  # Create a leaflet proxy. Proxies update map values without re-rendering the
  # entire map, thus increasing performance.
  observe({
  	# params() can be called without isolation here!
    params <- params()
    leafletProxy("exp_map", data = params$poly) %>%
      clearShapes() %>% # remove existing polygons
      clearControls() %>% # remove existing legends
    	# add new features:
      addPolygons(
        fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
        fillOpacity = 0.7,
        weight = 1,
        color = "black",
        opacity = 0.5,
        label = params$labels,
        highlightOptions = highlightOptions(
          weight = 2,
          color = "black",
          opacity = 0.5,
          fillOpacity = 1,
          bringToFront = TRUE,
          sendToBack = TRUE
        )
      ) %>%
      addLegend(
        position = "bottomright",
        na.label = "No data",
        pal = params$pal,
        values = params$values,
        opacity = 0.9,
        title = txts[[params$var]]$lgd,
        labFormat = labelFormat(suffix = txts[[params$var]]$unit)
      )
  })
```

### What changed?

-   The output now:

    -   Does not re-render from scratch - saving time and resources

    -   Does not reset the map - making exploration more seamless

![](resources/06_06.gif)

## Add interactive events

-   Currently the user can interact with the Leaflet map in various ways: zoom, pan, hover, ...

-   The Shiny programmer has no way of accessing what happens on the map after it is rendered

-   Solution: reactive events!

-   Many Shiny extensions like Leaflet allow you to observe events that happen on the map

### Leaflet events

-   Leaflet events are accessed like so:

::: {style="font-size: 20px;"}
`input$<Map ID>`{style="color: red;"}`_<Object type>`{style="color: green;"}`_<Event type>`{style="color: blue;"}
:::

-   Map ID refers to the ID given to the Leaflet widget, in our case this is `map_exp`

### Leaflet object types

-   Object type refers to a geometry type, can be one of:

    -   `marker` for points

    -   `shape` for polygons and lines

    -   `geojson` and `topojson` for data that was passed in GeoJSON or TopoJSON format

### Leaflet event types

-   Event type refers to the action that is performed on the geometry, one of:

    -   `click`

    -   `mouseover`

    -   `mouseout`

### Other events

-   Additionally, Leaflet has some more general events:

    -   `input$<Map ID>_click` triggers when the background of the map is clicked

    -   `input$<Map ID>_bounds` provides the bounding box of the current view

    -   `input$<Map ID>_zoom` provides the current zoom level

    -   `input$<Map ID>_center` provides the center point of the current view

-   **Question:** When does `input$map_exp_marker_click` trigger?

### Events in practice

-   The output of these Leaflet events usually contain an ID, Latitude and Longitude:

```{r include=FALSE}
input <- list()
input$map_exp_shape_click <- list(id = NULL, .nonce = 0.0504539489632481, lat = 49.003195289566, lng = -1.14056772662844)
```

```{r}
input$map_exp_shape_click
```

### Clear objects

-   In the following code chunk, we add a marker whenever we click on a polygon on the Leaflet map

    1.  Capture the click input

    2.  Remove previous markers

    3.  Add a new marker using the click coordinates

```{r eval=FALSE}
observe({
	click <- input$exp_map_shape_click
	req(click) # Cancel execution if click is not "truthy"
	leafletProxy("map_exp") %>% # Create proxy object
		clearMarkers() %>% # Remove ALL markers
		addMarkers(lng = click$lng, lat = click$lat) # add a new marker
})
```

![](resources/06_07.gif)

-   

-   Here, we remove all markers in order to add a new one, but we can also be more careful in deleting elements

    -   `leaflet::clear` functions remove all elements of a geometry type

    -   `leaflet::remove` functions remove one element by layer ID

::: callout-note
`leaflet::remove` functions need a layer ID to work! You can set them using the `layerId` argument in `leaflet::add` functions, e.g. `leaflet::addMarkers(..., layerId = "marker1")`
:::

```{r eval=FALSE}
# Add a new marker
observe({
	click <- input$exp_map_shape_click
	req(click)
	id <- paste0(click$lng, click$lat) # Generate an ID from long and lat values
	leafletProxy("exp_map") %>%
		addMarkers(lng = click$lng, lat = click$lat, layerId = id) # Create a marker with unique ID
})

# Delete an existing marker
observe({
	click <- input$exp_map_marker_click
	req(click)
	leafletProxy("exp_map") %>%
		removeMarker(click$id) # Remove a marker with when marker ID and click ID align
})
```

![](resources/06_08.gif)

::: {.callout-note collapse="true"}
## Bonus for the daring

-   You can create your own input events with a little bit of JavaScript!

-   In the code chunk below, we add a "mousemove" event, that triggers every time the mouse is moved on the Leaflet map

-   Note the use of `htmlwidgets::onRender()` to execute a piece of JavaScript when the Leaflet widget renders

-   Note the use of `Shiny.onInputChange` to create input events

-   Further reading: [Joe Cheng - "Communicating with Shiny via JavaScript"](https://shiny.posit.co/r/articles/build/communicating-with-js/)

```{r eval=FALSE}
output$exp_map <- renderLeaflet({
	leaflet() %>%
		htmlwidgets::onRender("function(el, x) {
      this.on('mousemove', function(e) {
        var lng = e.latlng.lng;
        var lat = e.latlng.lat;
        var coord = [lng, lat];            // capture long and lat
        Shiny.onInputChange('exp_map', coord)   // send coordinates to Shiny
      });
      this.on('mouseout', function(e) {
        Shiny.onInputChange('exp_map', null)    // reset coordinates when mouse leaves map
      })
    }")
})
```
:::

## Exercises

::: callout-note
### Exercise 1

Extract the `sfc` object from the `Guerry` dataset. What is the difference between `sf` and `sfc`?
:::

::: {.callout-tip collapse="true"}
Consult the documentation of `st_geometry()`
:::

::: {.callout-warning collapse="true"}
### Solution

```{r eval=FALSE}
st_geometry(guerry)
```

`sf` objects are dataframes containing of one or more non-spatial feature columns and a geometry column containing an `sfc` object

`sfc` objects are representations of geospatial geometries. They contain all relevant spatial metadata but no contextual feature data
:::

### 

::: callout-note
### Exercise 2

Extract the fifth `sfg` object of the `sfc` object from exercise 1. What is the difference between the two?
:::

::: {.callout-tip collapse="true"}
Objects of class `sfc` behave like lists and can be subset in the same fashion
:::

::: {.callout-warning collapse="true"}
### Solution

```{r eval=FALSE}
geom <- st_geometry(guerry)
geom[[1]]
```

`sfg` objects contain raw geometries consisting only of coordinates and a geometric topology (i.e. how to connect coordinates to make a polygon)

`sfc` objects have spatial metadata including the CRS which makes it possible to where the coordinates are located on the planet
:::

::: callout-note
### Exercise 3

`guerry` currently consists of multi polygons. How can we convert these polygons to point geometries? Explore the [function reference](https://r-spatial.github.io/sf/reference/index.html) of the sf package and find functions (multiple answers possible) that can convert polygons to points in some way.
:::

::: {.callout-tip collapse="true"}
A search for "point" can give you the most obvious functions to fulfill the task, but there's more!
:::

::: {.callout-warning collapse="true"}
### Solution

`st_point_on_surface(guerry)` returns a point that is guaranteed to be on the polygon

`st_centroid(guerry)` returns the geometrical center of the polygon

`st_cast(guerry, "POINT")` or `st_cast(guerry, "MULTIPOINT")`

All of them return a warning! [Why might that be?](https://r-spatial.github.io/sf/articles/sf1.html#how-attributes-relate-to-geometries)

`st_sample(guerry, size = rep(1, nrow(guerry)))`

Doesn't return a warning, but is random and drops all features
:::

::: callout-note
### Exercise 4

Currently, the `Guerry` dataframe has the CRS "NTF (Paris) / Lambert zone II", which is already a good choice. What other CRS could be a good choice for accurate mapping in France? What is the respective EPSG code?
:::

::: {.callout-tip collapse="true"}
Remember the UTM coordinate system! Scroll back up to see the UTM zones. EPSG codes can be looked up using <https://epsg.io/>
:::

::: {.callout-warning collapse="true"}
### Solution

While there are many CRS that might be a good choice, one solution that we addressed in this workshop are UTM zones! Taking a look at the figure of UTM zones we can see that UTM zone 31N almost entirely covers the area of France.

![](https://upload.wikimedia.org/wikipedia/commons/6/61/Modified_UTM_Zones.png)
:::

::: callout-note
### Exercise 5

Transform the `Guerry` dataframe to your new CRS from exercise 4.
:::

::: {.callout-tip collapse="true"}
Remember you can visit <https://epsg.io/> to look up EPSG codes.
:::

::: {.callout-warning collapse="true"}
### Solution

Using the search function on [epsg.io](https://epsg.io/) we can determine that the EPSG code to transform the Guerry dataset from Lambert zone II to UTM zone 31N is one of 23031, 25831 or 32631.

```{r eval=FALSE}
st_transform(guerry, 23031)
```
:::

::: callout-note
### Exercise 6

Add a marker of Paris to the Leaflet map. Add a popup that adds additional trivia information about the capital of France.
:::

::: {.callout-tip collapse="true"}
The coordinates of France are long = 2.351667, lat = 48.856667.
:::

::: {.callout-warning collapse="true"}
### Solution

Add a marker of Paris:

```{r eval=FALSE}
leaflet(data = params$poly) %>%
  addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
  addProviderTiles("OpenTopoMap", group = "OTM") %>%
  addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
  addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
  addLayersControl(baseGroups = c("OSM", "OTM",
                                  "Stamen Toner", "Orthophotos")) %>%
  setView(lng = 3, lat = 47, zoom = 5) %>%
  addPolygons(
    fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
    fillOpacity = 0.7,
    weight = 1,
    color = "black",
    opacity = 0.5,
    label = params$labels,
    highlightOptions = highlightOptions(
      weight = 2,
      color = "black",
      opacity = 0.5,
      fillOpacity = 1,
      bringToFront = TRUE,
      sendToBack = TRUE
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal = params$pal,
    values = params$values,
    opacity = 0.9,
    title = txts[[params$var]]$lgd,
    labFormat = labelFormat(suffix = txts[[params$var]]$unit)
  ) %>%
	addMarkers(
		lng = 2.351,
		lat = 48.856,
		popup = "When the Guerry dataset was published, around 800.000 people lived in the city of Paris"
	)
```
:::

::: callout-note
### Exercise 7

Change the icon of the marker from exercise 6 to an icon of a city and the color to red.
:::

::: {.callout-tip collapse="true"}
To figure out how to change marker options, refer to `?makeIcon` and `?makeAwesomeIcon`.

For icons, take a look at the `library` argument and the website \[https://fontawesome.com/\]
:::

::: {.callout-warning collapse="true"}
### Solution

To change the color and the icon, we need to work with "awesome markers". Icons can be made with the function `makeAwesomeIcon()` or `makeIcon()`. These functions support Icons from Glyphicon, Fontawesome and Ionicon.

```{r eval=FALSE}
... %>%
  addAwesomeMarkers(
      lng = 2.351,
      lat = 48.856,
      popup = "When the Guerry dataset was published, around 800.000 people lived in the city of Paris",
      icon = makeAwesomeIcon(icon = "city", library = "fa", markerColor = "red")
  )
```
:::

::: callout-note
### Exercise 8

Set the default plotting variable to "Distance to Paris"
:::

::: {.callout-tip collapse="true"}
Remember the `selected` argument in input UI components
:::

::: {.callout-warning collapse="true"}
### Solution

To change the default values of a reactive Shiny plot, you need to change the `selected` argument of the UI input `selectInput`

```{r eval=FALSE}
selectInput(
  "exp_select",
  label = "Select a variable",
  choices = setNames(variables, sapply(txts, "[[", "title"))
)
```
:::

::: callout-note
### Exercise 9

When does the event `input$map_exp_shape_mouseout` send information to the server?
:::

::: {.callout-tip collapse="true"}
A Leaflet input event is structured as follows: `input$<mapid>_<geometry type>_<event type>`.
:::

::: {.callout-warning collapse="true"}
### Solution

`map_exp` refers to the target leaflet map

`shape` refers to the target map object (in this case a polygon or a line)

`mouseout` refers to the event type

`input$map_exp_shape_mouseout` triggers whenever we move out of the boundaries of a polygon on the Leaflet map with the ID `map_exp`
:::

::: callout-note
### Exercise 10

Print the current mouse coordinates to the console every time a polygon on the map is clicked.
:::

::: {.callout-tip collapse="true"}
You can access click coordinates using the map event `input$map_exp_shape_click`
:::

::: {.callout-warning collapse="true"}
### Solution

To capture the the mouse coordinates we need to access the Leaflet event `input$exp_map_shape_click`. Printing to the console is done in an observer as it triggers side effects and does not create a reactive object.

```{r eval=FALSE}
observe({
	click <- input$exp_map_shape_click
	cat(paste(
		"Click on exp_map detected",
		paste("Lon:", click$lng),
		paste("Lat:", click$lat),
		"\n",
		sep = "\n"
	))
})
```
:::
