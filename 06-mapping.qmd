---
title: "Prototyping"
---

```{r include=FALSE}
pacman::p_load(
	shiny,
	htmltools,
	bs4Dash,
	fresh,
	waiter,
	shinyWidgets,
	Guerry,
	sf,
	tidyr,
	dplyr,
	RColorBrewer,
	viridis,
	leaflet,
	plotly,
	jsonlite
)

guerry <- Guerry::gfrance85 %>%
  st_as_sf() %>% # convert sp to the newer sf format
  as_tibble() %>%
  st_as_sf(crs = 27572) %>% # set the correct coordinate reference system
  mutate(Region = case_match(
    Region,
    "C" ~ "Central",
    "E" ~ "East",
    "N" ~ "North",
    "S" ~ "South",
    "W" ~ "West"
  ))

variables <- guerry %>%
  st_drop_geometry() %>%
  select(where(is.numeric) & !all_of(c("COUNT", "dept", "AVE_ID_GEO"))) %>%
  names()

guerry_region <- guerry %>%
  group_by(Region) %>%
  summarise(across(
  .cols = all_of(variables),
  function(x) {
    if (cur_column() %in% c("Area", "Pop1831")) {
      sum(x)
    } else {
      mean(x)
    }
  }
 ))
  
txts <- read_json("shinyapps/guerry/app_labels.json", simplifyVector = TRUE)
```

## Learning outcomes

You will learn how to:

-   Work with spatial data

-   Create interactive maps in Shiny using Leaflet

-   Use Shiny events and proxies

## Interactive maps

-   Mapping is a type of data visualization based on *spatial data*

-   Classic cartography relies on generalization and interpretation

-   Interactive cartography removes many limitations such as generalization and map boundaries

![Generalization in OpenStreetMap at different scales](resources/generalization.gif)

-   Further resources:

    -   [Chapter 9](https://r.geocompx.org/adv-map.html) of Robin Lovelace's "Geocomputation with R"

    -   The documentation of [Leaflet for R](https://rstudio.github.io/leaflet/)

## The basics

-   Spatial data is the foundation of mapping, but what is it?

-   Spatial data is all data that can be explicitly linked to a spatial reference (longitude/latitude)

-   Geography can describe the world in two ways:

    -   As spatially continuous processes (or as *raster data*)

    -   As an ensemble of individual elements (or as *vector data*)

-   In R, spatial data can be handled using various packages:

    -   `sp` (vector data) and `raster` (raster data) used to be the common packages for spatial analysis

    -   `sf` (vector data) and `terra` (raster data) are their more timely successors

-   Vector data is also called spatial geometries and can be divided into

    -   Points (e.g., individual events or places)

    -   Lines (e.g., streets, rivers)

    -   Polygons (e.g., buildings, districts)

![The real world described by layers of raster and vector data ([Source](https://saylordotorg.github.io/text_essentials-of-geographic-information-systems/s11-02-multiple-layer-analysis.html#campbell_1.0-ch07_s02_f01))](https://saylordotorg.github.io/text_essentials-of-geographic-information-systems/section_11/ca6ce94cdd2e09a1da8aa6ec22336835.jpg){width="440"}

-   All spatial data need to have a coordinate reference system (CRS) that locates the coordinates on the planet

-   The geodetic specifics are mostly not necessary, but it's always good to know a basic distinction

    -   **Geodetic CRS** use angular units (degrees) because they are based on a spheroid - good for visualization and quick overviews -- usually good for global or national scale visualizations

    -   **Projected CRS** use metric units (meters) because they are based on a projected model of the earth -- usually good for local or regional high-precision spatial analysis and visualization

![UTM (Universal Transversal Mercator) zones. Each zone is a CRS.](https://upload.wikimedia.org/wikipedia/commons/e/ed/Utm-zones.jpg)

-   **Question:** What can we say about the Guerry dataset in terms of spatial information?

```{r}
guerry["Literacy"]
```

## Interactive maps using Leaflet

-   R offers many solutions to mapping, some more advanced than others

    -   [`ggplot2`](https://cloud.r-project.org/web/packages/ggplot2/) supports spatial data with functions like [`geom_sf`](https://ggplot2.tidyverse.org/reference/ggsf.html), [`coord_sf`](https://ggplot2.tidyverse.org/reference/ggsf.html) and custom ones like [`stars::geom_stars`](https://r-spatial.github.io/stars/reference/geom_stars.html)

    -   [`tmap`](https://cran.r-project.org/web/packages/tmap/) is a comprehensive framework for high-quality thematic mapping

    -   [`cartography`](https://cran.r-project.org/web/packages/cartography/index.html) and [`mapsf`](https://cran.r-project.org/web/packages/mapsf/index.html) incorporate cartography principles to move R closer to dedicated mapping software

    -   [`leaflet`](https://cran.r-project.org/web/packages/leaflet/) interfaces the Leaflet JavaScript library to create interactive map visualizations

-   Leaflet in Shiny works just like any other type of visualization, we need:

    -   A UI output: [`leaflet::leafletOutput()`](https://rdrr.io/cran/leaflet/man/map-shiny.html)

    -   A rendering function: [`leaflet::renderLeaflet()`](https://rdrr.io/cran/leaflet/man/map-shiny.html)

-   In our app, we add a geographic explorer of the Guerry dataset

```{r eval=FALSE}
tabItem(
  tabName = "exp", # must correspond to related menuItem name
  fluidRow(
    column(
      width = 12,
      box(
        id = "exp_box",
        status = "primary",
        headerBorder = FALSE,
        collapsible = FALSE,
        width = 12,
        leaflet::leafletOutput("exp_map", height = "800px", width = "100%")
      ) # end box
    ) # end column
  ) # end fluidRow
) # end tabItem
```

-   The leaflet package is centered around the workhorse [`leaflet()`](https://rdrr.io/cran/leaflet/man/leaflet.html) which creates an empty map canvas

-   Each additional function can be piped into and adds an additional mapping component (similar to `ggplot2`)

    -   [`addProviderTiles()`](https://rdrr.io/cran/leaflet/man/addProviderTiles.html) adds a base map, in this case we use four base maps that can be chosen from

    -   [`addLayersControl()`](https://rdrr.io/cran/leaflet/man/addLayersControl.html) adds a button that lets you switch between map layers

    -   [`setView()`](https://rdrr.io/cran/leaflet/man/map-methods.html) sets the center and zoom level of the initial map view

```{r eval=FALSE}
output$exp_map <- leaflet::renderLeaflet({
		leaflet() %>%
			addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
			addProviderTiles("OpenTopoMap", group = "OTM") %>%
			addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
			addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
			addLayersControl(baseGroups = c("OSM", "OTM",
																			"Stamen Toner", "Orthophotos")) %>%
			setView(lng = 3, lat = 47, zoom = 5)
})
```

![](resources/06_01.gif)

## Add data

-   Currently, we only show a background, but do not map the Guerry data

-   Adding data works using layer functions, for example:

    -   [`addMarkers()`](https://rdrr.io/cran/leaflet/man/map-layers.html) adds point data

    -   [`addPolylines()`](https://rdrr.io/cran/leaflet/man/map-layers.html) adds line data

    -   [`addPolygons()`](https://rdrr.io/cran/leaflet/man/map-layers.html) adds polygon data

    -   [`addRasterImage()`](https://rdrr.io/cran/leaflet/man/addRasterImage.html) adds raster data

    -   [`addLegend()`](https://rdrr.io/cran/leaflet/man/addLegend.html) adds a legend

-   Variables are passed using formulas (i.e. instead of `guerry$Literacy`, we write `~Literacy`)

-   Palettes are applied using custom functions that are generated in function factories:

    -   `colorNumeric()` maps continuous values

    -   `colorBin()` bins continuous values evenly

    -   `colorQuantile()` bins continuous values based on their quantiles

    -   `colorFactor()` maps categorical values

-   `highlightOptions()` adds a nice highlight effect when hovering over a polygon

```{r eval=FALSE}
# Compile parameters for leaflet rendering
params <- reactive({
	values <- ~Literacy # passing data works using formulas
	pal <- colorNumeric(palette = "Reds", domain = NULL)
	
	list(
		var = var,
		pal = pal
	)
})

output$exp_map <- leaflet::renderLeaflet({
	# Isolate call to params() to prevent render function to be executed
	# every time params() is invalidated. No dependency is made.
	params <- params()
	leaflet(data = params$poly) %>%
		addProviderTiles("OpenStreetMap.France") %>%
		setView(lng = 3, lat = 47, zoom = 5) %>%
		addPolygons(
			fillColor = ~params$pal(Literacy),
			fillOpacity = 0.7,
			weight = 1,
			color = "black",
			opacity = 0.5,
			highlightOptions = highlightOptions( # add highlighting on hover
				weight = 2,
				color = "black",
				opacity = 0.5,
				fillOpacity = 1,
				bringToFront = TRUE,
				sendToBack = TRUE
			)
		) %>%
		addLegend(
			position = "bottomright",
			pal = params$pal,
			values = params$values,
			opacity = 0.9,
			title = "Literacy",
			labFormat = labelFormat(suffix = " %")
		)
})
```

![](resources/06_02.gif)

## Add reactivity

-   Similar to chapter 5 on visualization, reactivity is the key to making maps in Shiny

-   Similar to chapter 5, reactivity is arguably the most complex part of app development!

-   In our app, we add three reactive components:

    -   `selectInput()` to select a variable to map

    -   `radioButtons()` to select an aggregation level, departments or regions

    -   `selectInput()` to select a color palette

-   Additionally, one new UI output (`exp_desc`) is added that describes the selected variable

```{r}
# Define selectable palettes: All sequential palettes + viridis
pals <- list(
  Sequential = RColorBrewer::brewer.pal.info %>%
    filter(category %in% "seq") %>%
    row.names(),
  Viridis = c("Magma", "Inferno", "Plasma", "Viridis",
              "Cividis", "Rocket", "Mako", "Turbo")
)
```

```{r eval=FALSE}
# Define new tab item: "exp"
tabItem(
	tabName = "exp", # must correspond to related menuItem name
	fluidRow(
		column(
			width = 4, # must be between 1 and 12
			box(
				title = "Data selection",
				status = "primary",
				width = 12,
				selectInput(
					"exp_select",
					label = "Select a variable",
					choices = setNames(variables, sapply(txts, "[[", "title"))
				),
				uiOutput("exp_desc")
			),
			box(
				title = "Map configuration",
				status = "primary",
				width = 12,
				radioButtons(
					"exp_aggr",
					label = "Aggregation level",
					choices = c("Departments", "Regions"),
					selected = "Departments"
				),
				selectInput(
					"exp_pal",
					label = "Color palette",
					choices = pals,
					selected = "Reds"
				) # end input
			) # end box
		), # end column
		column(
			width = 8,
			box(
				id = "exp_box",
				status = "primary",
				headerBorder = FALSE,
				collapsible = FALSE,
				width = 12,
				leaflet::leafletOutput("exp_map", height = "800px", width = "100%")
			) # end box
		) # end column
	) # end fluidRow
) # end tabItem
```

-   To change the aggregation level, we need the Guerry dataset at different levels

-   The Guerry dataset contains two group variables: Department (smaller) and Region (larger)

-   We perform spatial aggregation on the Guerry dataset *outside* of the server function:

```{r}
# Extract variable names
variables <- guerry %>%
	st_drop_geometry() %>%
	select(where(is.numeric) & !all_of(c("COUNT", "dept", "AVE_ID_GEO"))) %>%
	names()

## Aggregate ----
guerry_region <- guerry %>%
	group_by(Region) %>%
	summarise(across(
		.cols = all_of(variables),
		function(x) {
			if (cur_column() %in% c("Area", "Pop1831")) {
				sum(x)
			} else {
				mean(x)
			}
		}
	))
```

-   We also unpack the text data that we stored in the working directory before

-   The JSON contains metadata to each Guerry variable, including titles, descriptions, legend titles and units

```{r}
# We also use the text data that we created before
txts <- read_json("shinyapps/guerry/app_labels.json", simplifyVector = TRUE)

str(txts)
```

-   In the server function, we have a lot to do (annotated with their respective letters in the code below):

    -   Render a description for the selected variable (A)

    -   Apply the selected aggregation level (B)

    -   Apply the selected palette (C)

    -   Change hard code to adaptive code (D)

```{r eval=FALSE}
	## Explore data ----
	
	# Render description of selected variable (A)
	output$exp_desc <- renderUI({
		HTML(txts[[input$exp_select]]$desc)
	})
	
	# Select polygon based on aggregation level (B)
	poly <- reactive({
		if (identical(input$exp_aggr, "Regions")) {
			guerry_region
		} else {
			guerry
		}
	})
	
	# Select palette based on input (C)
	palette <- reactive({
		pal <- input$exp_pal
		if (pal %in% pals$Viridis) {
			pal <- viridis::viridis_pal(option = tolower(pal))(5)
		}
		pal
	})
	
	# Compile parameters for leaflet rendering (D)
	params <- reactive({
		poly <- st_transform(poly(), 4326)
		pal <- palette()
		var <- input$exp_select
		
		values <- as.formula(paste0("~", var))
		pal <- colorNumeric(palette = pal, domain = NULL)
		
		list(
			poly = poly,
			var = var,
			pal = pal,
			values = values,
			labels = labels
		)
	})
	
	# Render leaflet for the first time
	output$exp_map <- leaflet::renderLeaflet({
		# Isolate call to params() to prevent render function to be executed
		# every time params() is invalidated. No dependency is made.
		params <- params()
		leaflet(data = params$poly) %>%
			addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
			addProviderTiles("OpenTopoMap", group = "OTM") %>%
			addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
			addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
			addLayersControl(baseGroups = c("OSM", "OTM",
																			"Stamen Toner", "Orthophotos")) %>%
			setView(lng = 3, lat = 47, zoom = 5) %>%
			addPolygons(
				fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
				fillOpacity = 0.7,
				weight = 1,
				color = "black",
				opacity = 0.5,
				highlightOptions = highlightOptions(
					weight = 2,
					color = "black",
					opacity = 0.5,
					fillOpacity = 1,
					bringToFront = TRUE,
					sendToBack = TRUE
				)
			) %>%
			addLegend(
				position = "bottomright",
				pal = params$pal,
				values = params$values,
				opacity = 0.9,
				title = txts[[params$var]]$lgd,
				labFormat = labelFormat(suffix = txts[[params$var]]$unit)
			)
	})
```

![](resources/06_03.gif)

## Add hover labels

-   Unlike Plotly, Leaflet does not automatically provide labels for data points

    -   Bad news: You have to do it on your own :(

    -   Good news: You have more freedom in designing hover labels :)

-   Adding labels is itself not a difficult task: You can just provide the values vector we use as data input:

```{r eval=FALSE}
leaflet() %>%
	addPolygons(
		..., # rest of the args
		label = ~values
	)
```

-   This is *enough*, but not very pretty and it doesn't provide potentially important metadata like region names

-   In our app, we use a table layout containing information about region, department and variable value

-   You can create generic HTML tables using the `table` tag (`tags$table`) together with the `tr` (table row, `tags$tr`) and `td` (table data, `tags$td`)

```{r}
tags$table(
	tags$tr(
		tags$td("Cell 1"),
		tags$td("Cell 2"),
		tags$td("Cell 3")
	),
		tags$tr(
		tags$td("Cell 4"),
		tags$td("Cell 5"),
		tags$td("Cell 6")
	),
		tags$tr(
		tags$td("Cell 7"),
		tags$td("Cell 8"),
		tags$td("Cell 9")
	)
)
```

![](https://vertex-academy.com/tutorials/wp-content/uploads/2016/08/table.png)

```{r eval=FALSE}
params <- reactive({
  poly <- st_transform(poly(), 4326)
  pal <- palette()
  var <- input$exp_select

  values <- as.formula(paste0("~", var))
  pal <- colorNumeric(palette = pal, domain = NULL)
  
  reg <- poly[["Region"]]
  dep <- poly[["Department"]]
  val <- poly[[var]]
  
  # If aggregated on region level, department will be NULL
  if (is.null(dep)) {
    dep <- rep(NA, nrow(poly))
  }

  # Create labels that are nicely aligned in a grid
  # If aggregated on region level, omit department name (because it is NULL)
  labels <- mapply(
    function(reg, dep, val) {
      HTML(as.character(tags$table(
      	# Add region row
        tags$tr(
          style = "line-height: 10px", # more compact layout
          tags$td(tags$b("Region: ")), # left-hand side
          tags$td(reg) # right-hand side
        ),
        # Add department row if available
        if (!is.na(dep)) {
          tags$tr(
            style = "line-height: 10px",
            tags$td(tags$b("Department: ")),
            tags$td(dep)
          )
        },
        # Add value row
        tags$tr(
          style = "line-height: 10px",
          tags$td(tags$b(paste0(txts[[var]]$lgd, ": "))),
          tags$td(round(val, 2))
        )
      )))
    },
    reg = reg, dep = dep, val = val,
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE
  )

  list(
    poly = poly,
    var = var,
    pal = pal,
    values = values,
    labels = labels
  )
  
  # Render leaflet for the first time
  output$exp_map <- leaflet::renderLeaflet({
    # Isolate call to params() to prevent render function to be executed
    # every time params() is invalidated. No dependency is made.
    params <- isolate(params())
    leaflet(data = params$poly) %>%
      addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
      addProviderTiles("OpenTopoMap", group = "OTM") %>%
      addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
      addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
      addLayersControl(baseGroups = c("OSM", "OTM",
                                      "Stamen Toner", "Orthophotos")) %>%
      setView(lng = 3, lat = 47, zoom = 5) %>%
      addPolygons(
        fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
        fillOpacity = 0.7,
        weight = 1,
        color = "black",
        opacity = 0.5,
        label = params$labels, # don't forget to pass the labels to the map!!
        highlightOptions = highlightOptions(
          weight = 2,
          color = "black",
          opacity = 0.5,
          fillOpacity = 1,
          bringToFront = TRUE,
          sendToBack = TRUE
        )
      ) %>%
      addLegend(
        position = "bottomright",
        pal = params$pal,
        values = params$values,
        opacity = 0.9,
        title = txts[[params$var]]$lgd,
        labFormat = labelFormat(suffix = txts[[params$var]]$unit)
      )
  })
})
```

![](resources/06_04.gif)

## Add proxies

-   The map already looks quite polished!

-   One more problem: Map updates!

-   Map re-renders every time an input is invalidated:

    -   Everything needs to be redrawn = slow for large datasets

    -   Map view resets with every update:

![](resources/06_05.gif)

-   Solution: Proxies

-   Proxy objects are representations of existing widgets that can manipulate existing widgets in place

-   Many Shiny extensions provide proxy functions:

    -   [`DT::dataTableProxy()`](https://rdrr.io/cran/DT/man/proxy.html)

    -   [`plotly::plotlyProxy()`](https://rdrr.io/cran/plotly/man/plotlyProxy.html)

    -   [`leaflet::leafletProxy()`](https://rdrr.io/cran/leaflet/man/leafletProxy.html)

-   Proxy workflow:

    1.  Initialize an isolated output widget (i.e., no dependencies)

    2.  Create an observer that updates input dependencies

    3.  Invalidate an input

    4.  Remove existing features and add new ones

-   To create an isolated output widget, we use the `isolate()` function from Shiny

    -   The `params()` reactive is executed only *once*, but does take a dependency

```{r eval=FALSE}
  # Render leaflet for the first time
  output$exp_map <- leaflet::renderLeaflet({
    # Isolate call to params() to prevent render function to be executed
    # every time params() is invalidated. No dependency is made.
    params <- isolate(params())
    leaflet(data = params$poly) %>%
      addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
      addProviderTiles("OpenTopoMap", group = "OTM") %>%
      addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
      addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
      addLayersControl(baseGroups = c("OSM", "OTM",
                                      "Stamen Toner", "Orthophotos")) %>%
      setView(lng = 3, lat = 47, zoom = 5) %>%
      addPolygons(
        fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
        fillOpacity = 0.7,
        weight = 1,
        color = "black",
        opacity = 0.5,
        label = params$labels,
        highlightOptions = highlightOptions(
          weight = 2,
          color = "black",
          opacity = 0.5,
          fillOpacity = 1,
          bringToFront = TRUE,
          sendToBack = TRUE
        )
      ) %>%
      addLegend(
        position = "bottomright",
        pal = params$pal,
        values = params$values,
        opacity = 0.9,
        title = txts[[params$var]]$lgd,
        labFormat = labelFormat(suffix = txts[[params$var]]$unit)
      )
  })
```

-   Instead, we create an observer that updates the map layers *in place*

-   First, all existing features that are to be changed are cleared

-   Second, new features are added in the usual piping manner

```{r eval=FALSE}
  # Create a leaflet proxy. Proxies update map values without re-rendering the
  # entire map, thus increasing performance.
  observe({
  	# params() can be called without isolation here!
    params <- params()
    leafletProxy("exp_map", data = params$poly) %>%
      clearShapes() %>% # remove existing polygons
      clearControls() %>% # remove existing legends
    	# add new features:
      addPolygons(
        fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
        fillOpacity = 0.7,
        weight = 1,
        color = "black",
        opacity = 0.5,
        label = params$labels,
        highlightOptions = highlightOptions(
          weight = 2,
          color = "black",
          opacity = 0.5,
          fillOpacity = 1,
          bringToFront = TRUE,
          sendToBack = TRUE
        )
      ) %>%
      addLegend(
        position = "bottomright",
        na.label = "No data",
        pal = params$pal,
        values = params$values,
        opacity = 0.9,
        title = txts[[params$var]]$lgd,
        labFormat = labelFormat(suffix = txts[[params$var]]$unit)
      )
  })
```

## Exercises

::: callout-note
## Exercise 1

Extract the raw geometries of the `Guerry` dataset.
:::

::: {.callout-tip collapse="true"}
Consult the documentation of `st_geometry()`
:::

::: callout-note
## Exercise 2

Extract the first of the geometries from exercise 1.
:::

::: {.callout-tip collapse="true"}
Objects of class `sfc` behave like lists and can be subset in the same fashion
:::

::: callout-note
## Exercise 3

What is the differences between the `Guerry` dataset and the outputs of exercise 1 and 2?
:::

::: {.callout-tip collapse="true"}
Check the `class` of each of the objects. Also check the printed information of each object.
:::

::: callout-note
## Exercise 4

Add a marker of Paris to the Leaflet map.
:::

::: {.callout-tip collapse="true"}
The coordinates of France are long = 2.351667, lat = 48.856667
:::

::: callout-note
## Exercise 5

Add a popup that adds additional information about the capital of France
:::

::: {.callout-tip collapse="true"}
`popup` and `popupOptions` are arguments of `addMarkers()`
:::

::: callout-note
## Exercise 6

Set the default plotting variable to "Distance to Paris"
:::

::: {.callout-tip collapse="true"}
Remember the `selected` argument in input UI components
:::
