---
title: "Mapping data & advanced visualization"
---

```{r include=FALSE}
pacman::p_load(
	shiny,
	htmltools,
	bs4Dash,
	fresh,
	waiter,
	shinyWidgets,
	Guerry,
	sf,
	tidyr,
	dplyr,
	RColorBrewer,
	viridis,
	leaflet,
	plotly,
	jsonlite
)

variable_names <- list(
  Crime_pers = "Crime against persons",  
  Crime_prop =  "Crime against property",  
  Literacy = "Literacy",  
  Donations = "Donations to the poor",  
  Infants = "Illegitimate births",  
  Suicides = "Suicides",  
  Wealth = "Tax / capita",  
  Commerce = "Commerce & Industry",  
  Clergy = "Clergy",  
  Crime_parents = "Crime against parents",  
  Infanticide = "Infanticides",  
  Donation_clergy = "Donations to the clergy",  
  Lottery = "Wager on Royal Lottery",  
  Desertion = "Military desertion",  
  Instruction = "Instruction",  
  Prostitutes = "Prostitutes",  
  Distance = "Distance to paris",  
  Area = "Area",  
  Pop1831 = "Population"
)

data_guerry <- Guerry::gfrance85 %>%
  st_as_sf() %>%
  as_tibble() %>%
  st_as_sf(crs = 27572) %>%
  mutate(Region = case_match(
    Region,
    "C" ~ "Central",
    "E" ~ "East",
    "N" ~ "North",
    "S" ~ "South",
    "W" ~ "West"
  )) %>%
  select(-c("COUNT", "dept", "AVE_ID_GEO", "CODE_DEPT")) %>%
  select(Region:Department, all_of(names(variable_names)))
```


You will learn how to:

- Work with spatial data
- Create interactive maps in Shiny using Leaflet
- Use Shiny events and proxies

# Interactive maps

- Mapping is a type of data visualization based on *spatial data*
- Classic cartography relies on generalization and interpretation
- Interactive cartography removes many limitations such as generalization and map boundaries

![Generalization in OpenStreetMap at different scales](resources/generalization.gif)

- Further resources:
    - [Chapter 9](https://r.geocompx.org/adv-map.html) of Robin Lovelace's "Geocomputation with R"
    - The documentation of [Leaflet for R](https://rstudio.github.io/leaflet/)

# Basics of spatial data

- Spatial data is the foundation of mapping, but what is it?

- Spatial data is all data that can be explicitly linked to a spatial reference (longitude/latitude)

| val    | lon        | lat       |
|--------|------------|-----------|
| 5.234  | 52.5646345 | 7.4326654 |
| 72.360 | 51.3453453 | 7.3242334 |
| 12.543 | 52.4564561 | 7.2323423 |

: A very basic form of spatial data

## Types of spatial data

- Geography can describe the world in two ways:
    - As spatially continuous processes (or as *raster data*)
    - As an ensemble of individual elements (or as *vector data*)
- Vector data is also called spatial geometries and can be divided into
    - Points (e.g., individual events or places)
    - Lines (e.g., streets, rivers)
    - Polygons (e.g., buildings, districts)

![The real world described by layers of raster and vector data ([Source](https://saylordotorg.github.io/text_essentials-of-geographic-information-systems/s11-02-multiple-layer-analysis.html#campbell_1.0-ch07_s02_f01))](https://saylordotorg.github.io/text_essentials-of-geographic-information-systems/section_11/ca6ce94cdd2e09a1da8aa6ec22336835.jpg){width="440"}

## Spatial data in R

- In R, spatial data can be handled using various packages:
    - `sp` (vector data) and `raster` (raster data) used to be the common packages for spatial analysis
    - `sf` (vector data) and `terra` (raster data) are their more timely successors
- By default, `data_guerry` is an sp object, but we converted it to an sf dataframe
- `sf` dataframes consist of a geometry column (class `sfc`) and multiple features (i.e. non-spatial columns)
- `sfc` geometries are list-like objects that consist of individual geometries (class `sfg`) and spatial metadata (e.g. type or dimension)
- `sfg` objects are matrices consisting purely of coordinates

```{r}
st_sf(                     # <1>
	feature = c(1, 2),       # <2>
	geometry =               # <3>
		st_sfc(                # <4>
			st_point(c(1, 1)),   # <5>
			st_point(c(1, 2)),   # <5>
		  st_point(c(2, 2)),   # <5>
			st_point(c(2, 1))    # <5>
		)                      # <5>
)
```

1.  Create an sf dataframe
2.  Create a feature column -- essentially a regular non-spatial column
3.  Create a geometry column containing an `sfc` object
4.  `sfc` = geometry + spatial metadata
5.  `sfg` = raw geometries

## Coordinate reference systems

- All spatial data need to have a **coordinate reference system** (CRS) that locates the coordinates on the planet
- The geodetic specifics are mostly not necessary, but it's always good to know a basic distinction
    - **Geodetic CRS**
        - Uses angular units (degrees) because they are based on a spheroid
        - Usually good for global or national scale visualizations
        - Example: WGS84 (World Geodetic System)
    - **Projected CRS**
        - Uses metric units (meters) because they are based on a projected model of the earth
        - Usually good for local or regional high-precision spatial analysis and visualization
        - Example: UTM (Universal Transversal Mercator)

![UTM (Universal Transversal Mercator) - a projected coordinate system. Each zone is a CRS.](https://upload.wikimedia.org/wikipedia/commons/e/ed/Utm-zones.jpg)

## EPSG codes

- CRS can be referenced using numeric identifiers called EPSG codes
    - EPSG database: <https://epsg.io/>, e.g. EPSG code 4326: <https://epsg.io/4326>

| Name                                                                                      | EPSG code | Area           | Geodetic? | Use                                                       |
|---------------|---------------|---------------|---------------|---------------|
| [World Geodetic System 1984 (WGS84)](https://en.wikipedia.org/wiki/World_Geodetic_System) | 4326      | World          | Yes       | Basic geographic coordinates, common usage in GPS systems |
| [WGS 84 / Pseudo-Mercator](https://en.wikipedia.org/wiki/Web_Mercator_projection)         | 3857      | World          | No        | Google Maps, OpenStreetMap, general web mapping           |
| [UTM zone 32N](https://de.wikipedia.org/wiki/UTM-Koordinatensystem)                       | 25832     | Central Europe | No        | Spatial analysis and measuring in Central Europe          |
| [LAEA Europe](https://en.wikipedia.org/wiki/European_grid)                                | 3035      | Europe         | No        | Multi-purpose CRS developed by the EU                     |

: Some common CRS

## CRS in R

- How do we work with CRS in R?
    - Convert to an sf dataframe: [`st_as_sf`](https://r-spatial.github.io/sf/reference/st_as_sf.html)`(..., crs = 4326)`
    - Assign a CRS to an existing sf dataframe: [`st_crs`](https://r-spatial.github.io/sf/reference/st_crs.html)`(...) <- 4326` or `st_set_crs(â€¦, 4326)`
    - Transform an existing CRS to a new CRS: [`st_transform`](https://r-spatial.github.io/sf/reference/st_transform.html)`(..., 4326)`

<!-- -->

## Handling the Guerry dataset

- Let us take a look back at `data_guerry` and how to handle it as a spatial dataframe
- `Guerry::gfrance85` comes as an `sp` dataframe, that's a bit old so we have to convert it
- The dataset also comes with an invalid CRS, so we need to fix it

```{r eval=FALSE}
data_guerry <- Guerry::gfrance85 %>% # <1>
  st_as_sf() %>%                     # <2>
  as_tibble() %>%                    # <3>
  st_as_sf(crs = 27572) %>%          # <4>
  mutate(Region = case_match(        # <5>
    Region,                          # <5>
    "C" ~ "Central",                 # <5>
    "E" ~ "East",                    # <5>
    "N" ~ "North",                   # <5>
    "S" ~ "South",                   # <5>
    "W" ~ "West"                     # <5>
  )) %>%                             # <5>
  select(-c("COUNT", "dept", "AVE_ID_GEO", "CODE_DEPT")) %>% # drop columns
  select(Region:Department, all_of(names(variable_names))) # select columns
```

1.  `Guerry::gfrance85` comes as an sp object and it has no CRS information
2.  ..., so we convert it to an sf dataframe
3.  Also convert it to a tibble to make it look nicer
4.  Finally, convert it back to sf and set the CRS to 25572 (which is the native CRS of the Guerry data)
5.  Here, we change the region coding that can be used for spatial aggregation

## Spatial operations

- For mapping the Guerry data, a nice addition is to perform spatial aggregation to compare the data across geographical levels
- Spatial operations like spatial aggregations are one of the main advantages of spatial over regular data
- In Guerry, we have two levels: Departments (smaller) and regions (larger)
- In the following chunk we perform spatial aggregation *outside* of the server function

```{r}
data_guerry_region <- data_guerry %>%
	group_by(Region) %>%                               # <1>
	summarise(across(                                  # <2>
		.cols = all_of(names(variable_names)),                       # <2>
		function(x) {                                    # <2>
			if (cur_column() %in% c("Area", "Pop1831")) {  # <2>
				sum(x)                                       # <2>
			} else {                                       # <2>
				mean(x)                                      # <2>
			}                                              # <2>
		}                                                # <2>
	))                                                 # <2>
```

1.  Define a group variable (Region)
2.  Aggregate Guerry variables and geometries by their grouping variable `Region`. Features are summed or averaged while geometries are merged.

## Guerry as spatial data

- **Question:** What can we say about the Guerry dataset in terms of spatial information?

```{r}
data_guerry["Literacy"]
```

## Exercise 1

::: callout-note
Extract the `sfc` object from the `Guerry` dataset. What is the difference between `sf` and `sfc`?
:::

::: {.callout-tip collapse="true"}
Consult the documentation of `st_geometry()`
:::

::: {.callout-warning collapse="true"}
## Solution

```{r eval=FALSE}
st_geometry(data_guerry)
```

`sf` objects are dataframes containing of one or more non-spatial feature columns and a geometry column containing an `sfc` object

`sfc` objects are representations of geospatial geometries. They contain all relevant spatial metadata but no contextual feature data
:::

## Exercise 2

::: callout-note
Extract the fifth `sfg` object of the `sfc` object from exercise 1. What is the difference between the two?
:::

::: {.callout-tip collapse="true"}
Objects of class `sfc` behave like lists and can be subset in the same fashion
:::

::: {.callout-warning collapse="true"}
## Solution

```{r eval=FALSE}
geom <- st_geometry(data_guerry)
geom[[1]]
```

`sfg` objects contain raw geometries consisting only of coordinates and a geometric topology (i.e. how to connect coordinates to make a polygon)

`sfc` objects have spatial metadata including the CRS which makes it possible to where the coordinates are located on the planet
:::

## Exercise 3

::: callout-note
`data_guerry` currently consists of multi polygons. How can we convert these polygons to point geometries? Explore the [function reference](https://r-spatial.github.io/sf/reference/index.html) of the sf package and find functions (multiple answers possible) that can convert polygons to points in some way.
:::

::: {.callout-tip collapse="true"}
A search for "point" can give you the most obvious functions to fulfill the task, but there's more!
:::

::: {.callout-warning collapse="true"}
## Solution

`st_point_on_surface(data_guerry)` returns a point that is guaranteed to be on the polygon

`st_centroid(data_guerry)` returns the geometrical center of the polygon

`st_cast(data_guerry, "POINT")` or `st_cast(data_guerry, "MULTIPOINT")`

All of them return a warning! [Why might that be?](https://r-spatial.github.io/sf/articles/sf1.html#how-attributes-relate-to-geometries)

`st_sample(data_guerry, size = rep(1, nrow(data_guerry)))`

Doesn't return a warning, but is random and drops all features
:::

## Exercise 4

Currently, the `Guerry` dataframe has the CRS "NTF (Paris) / Lambert zone II", which is already a good choice. What other CRS could be a good choice for accurate mapping in France?

::: {.callout-tip collapse="true"}
Remember the UTM coordinate system! Scroll back up to see the UTM zones.
:::

::: {.callout-warning collapse="true"}
## Solution

While there are many CRS that might be a good choice, one solution that we addressed in this workshop are UTM zones! Taking a look at the figure of UTM zones we can see that UTM zone 31N almost entirely covers the area of France.

![](https://upload.wikimedia.org/wikipedia/commons/6/61/Modified_UTM_Zones.png)
:::

## Exercise 5

Transform the `Guerry` dataframe to your new CRS from exercise 4.

::: {.callout-tip collapse="true"}
Remember you can visit <https://epsg.io/> to look up EPSG codes.
:::

::: {.callout-warning collapse="true"}
## Solution

Using the search function on [epsg.io](https://epsg.io/?q=utm+zone+31n) we can determine that the EPSG code to transform the Guerry dataset from Lambert zone II to UTM zone 31N is one of 23031, 25831 or 32631.

```{r eval=FALSE}
  st_transform(data_guerry, 23031)
```
:::

# Interactive maps using Leaflet

- R offers many solutions to mapping, some more advanced than others

    - [`ggplot2`](https://cloud.r-project.org/web/packages/ggplot2/) supports spatial data with functions like [`geom_sf`](https://ggplot2.tidyverse.org/reference/ggsf.html), [`coord_sf`](https://ggplot2.tidyverse.org/reference/ggsf.html) and custom ones like [`stars::geom_stars`](https://r-spatial.github.io/stars/reference/geom_stars.html)
    - [`tmap`](https://cran.r-project.org/web/packages/tmap/) is a comprehensive framework for high-quality thematic mapping
    - [`cartography`](https://cran.r-project.org/web/packages/cartography/index.html) and [`mapsf`](https://cran.r-project.org/web/packages/mapsf/index.html) incorporate cartography principles to move R closer to dedicated mapping software
    - [`leaflet`](https://cran.r-project.org/web/packages/leaflet/) interfaces the Leaflet JavaScript library to create interactive map visualizations

## Integrate Leaflet in Shiny

- Leaflet in Shiny works just like any other type of visualization, we need:
    - A UI output: [`leaflet::leafletOutput()`](https://rdrr.io/cran/leaflet/man/map-shiny.html)
    - A rendering function: [`leaflet::renderLeaflet()`](https://rdrr.io/cran/leaflet/man/map-shiny.html)
- In our app, we add a geographic explorer of the Guerry dataset

```{r eval=FALSE}
tabItem(                       # <1>
  tabName = "tab_map",             # <1>
  fluidRow(                    # <2>
    column(                    # <2>
      width = 12,              # <2>
      box(                     # <2>
        id = "tab_map_box",        # <2>
        status = "primary",    # <2>
        headerBorder = FALSE,  # <2>
        collapsible = FALSE,   # <2>
        width = 12,            # <2>
        leaflet::leafletOutput("tab_map_map", height = "800px", width = "100%") # <3>
      ) # end box
    ) # end column
  ) # end fluidRow
) # end tabItem
```

1.  Create a new tab called `tab_map`
2.  Add a fluid row containing a column and a box covering the entire page
3.  Add a UI output that will hold the leaflet map. It covers the entire width and 800 pixels in height.

## Leaflet workhorse

- The leaflet package is centered around the workhorse [`leaflet()`](https://rdrr.io/cran/leaflet/man/leaflet.html) which creates an empty map canvas
- Each additional function can be piped into and adds an additional mapping component (similar to `ggplot2`)
    - [`addProviderTiles()`](https://rdrr.io/cran/leaflet/man/addProviderTiles.html) adds a base map, in this case we use four base maps that can be chosen from
    - [`addLayersControl()`](https://rdrr.io/cran/leaflet/man/addLayersControl.html) adds a button that lets you switch between map layers
    - [`setView()`](https://rdrr.io/cran/leaflet/man/map-methods.html) sets the center and zoom level of the initial map view

```{r eval=FALSE}
output$tab_map_map <- leaflet::renderLeaflet({                                   # <1>
		leaflet() %>%                                                            # <2>
			addProviderTiles("OpenStreetMap.France", group = "OSM") %>%            # <3>
			addProviderTiles("OpenTopoMap", group = "OTM") %>%                     # <3>
			addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%       # <3>
			addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>% # <3>
			addLayersControl(baseGroups = c("OSM", "OTM",                          # <4>
																			"Stamen Toner", "Orthophotos")) %>%    # <4>
			setView(lng = 3, lat = 47, zoom = 5)                                   # <5>
})
```

1.  Fill the output `tab_map_map` with a leaflet map using `renderLeaflet`
2.  Add an empty map using the power horse `leaflet()`
3.  Add multiple basemaps: OpenStreetMap, OpenTopoMap, Stamen and ortho photos from the French geo portal
4.  Add a button to control which of the basemaps to show
5.  Set the initial center of the map and the zoom level

![](resources/06_01.gif)

## Full code

```{r eval=FALSE, file="shinyapps/guerry/states/06_mapping01.R"}
#| code-fold: true
#| code-summary: Full code including an empty map
```


# Add data

- Currently, we only show a background, but do not map the Guerry data
- Adding data works using layer functions, for example:
    - [`addMarkers()`](https://rdrr.io/cran/leaflet/man/map-layers.html) adds point data
    - [`addPolylines()`](https://rdrr.io/cran/leaflet/man/map-layers.html) adds line data
    - [`addPolygons()`](https://rdrr.io/cran/leaflet/man/map-layers.html) adds polygon data
    - [`addRasterImage()`](https://rdrr.io/cran/leaflet/man/addRasterImage.html) adds raster data
    - [`addLegend()`](https://rdrr.io/cran/leaflet/man/addLegend.html) adds a legend

## Specifics of Leaflet mapping

- Variables are passed using formulas (i.e. instead of `data_guerry$Literacy`, we write `~Literacy`)
- Leaflet by default only supports WGS84 (EPSG:4326) as CRS
- Palettes are applied using custom functions that are generated in function factories:
    - `colorNumeric()` maps continuous values
    - `colorBin()` bins continuous values evenly
    - `colorQuantile()` bins continuous values based on their quantiles
    - `colorFactor()` maps categorical values
- `highlightOptions()` adds a nice highlight effect when hovering over a polygon

```{r eval=FALSE}
output$tab_map_map <- leaflet::renderLeaflet({
	pal <- colorNumeric(palette = "Reds", domain = NULL)  # <1>
	
	leaflet(data = st_transform(data_guerry, 4326)) %>%   # <2>
		addProviderTiles("OpenStreetMap.France") %>%        # <3>
		setView(lng = 3, lat = 47, zoom = 5) %>%            # <4>
		addPolygons(                                        # <5>
			fillColor = ~params$pal(Literacy),                # <6>
			fillOpacity = 0.7,                                # <7>
			weight = 1,                                       # <7>
			color = "black",                                  # <7>
			opacity = 0.5,                                    # <7>
			highlightOptions = highlightOptions(              # <8>
				weight = 2,                                     # <8>
				color = "black",                                # <8>
				opacity = 0.5,                                  # <8>
				fillOpacity = 1,                                # <8>
				bringToFront = TRUE,                            # <8>
				sendToBack = TRUE                               # <8>
			)                                                 # <8>
		) %>%                                               # <8>
		addLegend(                                          # <9>
			position = "bottomright",                         # <9>
			pal = params$pal,                                 # <10>
			values = params$values,                           # <10>
			opacity = 0.9,
			title = "Literacy",
			labFormat = labelFormat(suffix = " %")            # <11>
		)
})
```

1.  Determine the color palette for mapping. Here, we want to map continious values in red. The output is a function called `pal()` which we can use later on.
2.  Create an empty map. Add spatial data. Note that leaflet by default only accepts spatial data with EPSG:4326. For anything else, consult [`leaflet::leafletCRS()`](https://rstudio.github.io/leaflet/projections.html), but don't expect to understand much of what's going on.
3.  Add a basemap of OpenStreetMap France
4.  Set the center and zoom level of the initial view
5.  The `addPolygons()` function adds polygons to the leaflet map
6.  `fillColor` determines how the polygons should be colored. We pass a formula that contains a call to our generated function `pal()` (see point 2) that maps colors to the Literacy variable.
7.  We can add additional parameters that control the appearance of the map, e.g. opacity, color or line thickness (weight).
8.  `highlightOptions()` allows you to add a nice highlight effect when hovering over the polygons
9. Using `addLegend()` we add a legend to the bottom right of the Leaflet map
10. `addLegend()` accepts values in the same way as `addPolygons()`: `pal` accepts the generated palette function and `values` accepts a formula containing the column name in the input dataset.
11. Finally, `labelFormat()` allows you to change the formatting of the legend label, e.g. if you need to specify whether a number is a percentage, meters or something else

![](resources/06_02.gif)
## Full code

```{r eval=FALSE, file="shinyapps/guerry/states/06_mapping02.R"}
#| code-fold: true
#| code-summary: Full code including a simple Leaflet map
```


# Add reactivity

- Similar to chapter 5 on visualization, reactivity is the key to making maps in Shiny
- Similar to chapter 5, reactivity is arguably the most complex part of app development!

## Reactive UI

- In our app, we add three reactive components:
    - `selectInput()` to select a variable to map
    - `radioButtons()` to select an aggregation level, departments or regions
    - `selectInput()` to select a color palette
- Additionally, one new UI output (`tab_map_desc`) is added that describes the selected variable

```{r}
# Define selectable palettes: All sequential palettes + viridis
pals <- list(
  Sequential = RColorBrewer::brewer.pal.info %>%
    filter(category %in% "seq") %>%
    row.names(),
  Viridis = c("Magma", "Inferno", "Plasma", "Viridis",
              "Cividis", "Rocket", "Mako", "Turbo")
)
```

```{r eval=FALSE}
tabItem(
	tabName = "tab_map",
	fluidRow(
		column(                                     # <1>
			width = 4,                                # <1>
			box(                                      # <1>
				title = "Data selection",               # <1>
				status = "primary",                     # <1>
				width = 12,                             # <1>
				selectInput(                            # <2>
					"tab_map_select",                         # <2>
					label = "Select a variable",          # <2>
					choices = setNames(variable_names, names(variable_names)) # <2>
				)                                      # <2>
			),
			box(                                      # <3>
				title = "Map configuration",            # <3>
				status = "primary",                     # <3>
				width = 12,                             # <3>
				radioButtons(                           # <4>
					"tab_map_aggr",                           # <4>
					label = "Aggregation level",          # <4>
					choices = c("Departments", "Regions"),# <4>
					selected = "Departments"              # <4>
				),                                      # <4>
				selectInput(                            # <5>
					"tab_map_pal",                            # <5>
					label = "Color palette",              # <5>
					choices = pals,                       # <5>
					selected = "Reds"                     # <5>
				) # end input
			) # end box
		), # end column
		column(
			width = 8,
			box(
				id = "tab_map_box",
				status = "primary",
				headerBorder = FALSE,
				collapsible = FALSE,
				width = 12,
				leaflet::leafletOutput("tab_map_map", height = "800px", width = "100%")
			) # end box
		) # end column
	) # end fluidRow
) # end tabItem
```

1.  Previously, the map tab only consisted of one column with a box. Now we add another column that occupies 1/3 of the page where we add our UI inputs
2.  Add a dropdown menu that selects a variable to map
3.  Add a second box. Since both boxes have a width of 12

## Server side

- In the server function, we have a lot to do (annotated with their respective letters in the code below):
    - Apply the selected aggregation level
    - Apply the selected palette
    - Change hard code to adaptive code

```{r eval=FALSE}
	# Select polygon based on aggregation level
	poly <- reactive({                                 # <1>
		if (identical(input$tab_map_aggr, "Regions")) {  # <1>
			data_guerry_region                             # <1>
		} else {                                         # <1>
			data_guerry                                    # <1>
		}                                                # <1>
	})                                                 # <1>
	
	# Select palette based on input
	palette <- reactive({                                     # <2>
		pal <- input$tab_map_pal                                # <2>
		if (pal %in% pals$Viridis) {                            # <2>
			pal <- viridis::viridis_pal(option = tolower(pal))(5) # <2>
		}                                                       # <2>
		pal                                                     # <2>
	})                                                        # <2>
	
	# Compile parameters for leaflet rendering
	params <- reactive({                                      # <3>
		poly <- st_transform(poly(), 4326)                      # <3>
		pal <- palette()                                        # <3>
		var <- input$tab_map_select                             # <3>
		                                                        # <3>
		values <- as.formula(paste0("~", var))                  # <3>
		pal <- colorNumeric(palette = pal, domain = NULL)       # <3>
		                                                        # <3>
		list(                                                   # <3>
			poly = poly,                                          # <3>
			var = var,                                            # <3>
			pal = pal,                                            # <3>
			values = values                                       # <3>
		)                                                       # <3>
	})                                                        # <3>
	
	# Render leaflet for the first time
	output$tab_map_map <- leaflet::renderLeaflet({
		# Isolate call to params() to prevent render function to be executed
		# every time params() is invalidated. No dependency is made.
		params <- params()                                      # <4>
		leaflet(data = params$poly) %>%                         # <4>
			addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
			addProviderTiles("OpenTopoMap", group = "OTM") %>%
			addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
			addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
			addLayersControl(baseGroups = c("OSM", "OTM",
																			"Stamen Toner", "Orthophotos")) %>%
			setView(lng = 3, lat = 47, zoom = 5) %>%
			addPolygons(
				fillColor = as.formula(paste0("~params$pal(", params$var, ")")), # <4>
				fillOpacity = 0.7,
				weight = 1,
				color = "black",
				opacity = 0.5,
				highlightOptions = highlightOptions(
					weight = 2,
					color = "black",
					opacity = 0.5,
					fillOpacity = 1,
					bringToFront = TRUE,
					sendToBack = TRUE
				)
			) %>%
			addLegend(
				position = "bottomright",
				pal = params$pal, # <4>
				values = params$values, # <4>
				opacity = 0.9
			)
	})
```

1. In a reactive expression called `poly()` we catch the selected aggregation level and decide whether to use the original `data_guerry` or the aggregated variant `data_guerry_region`.
2. In a reactive expression called `palette()` we catch the selected palette and match it with the available palette names.
3. We combine all inputs in a reactive expression called `params()` where we do the remaining data wrangling before the input data goes into leaflet mapping
4. Finally, we do the mapping and replace all previously hard-coded information with our new reactive data. This includes the input dataframe which is now simply `params$poly`, the fill color which is now a formula that is pasted together from the palette function and the selected variable and finally the palette and values required for the legend.

![](resources/06_03.gif)

::: callout-note
## Exercise 6
Add a marker of Paris to the Leaflet map. Add a popup that adds fun trivia information about the capital of France.
:::

::: {.callout-tip collapse="true"}
The coordinates of France are long = 2.351667, lat = 48.856667.
:::

::: {.callout-warning collapse="true"}
## Solution

Add a marker of Paris:

```{r eval=FALSE}
leaflet(data = params$poly) %>%
  addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
  addProviderTiles("OpenTopoMap", group = "OTM") %>%
  addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
  addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
  addLayersControl(baseGroups = c("OSM", "OTM", "Stamen Toner", "Orthophotos")) %>%
  setView(lng = 3, lat = 47, zoom = 5) %>%
  addPolygons(
    fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
    fillOpacity = 0.7,
    weight = 1,
    color = "black",
    opacity = 0.5,
    highlightOptions = highlightOptions(
      weight = 2,
      color = "black",
      opacity = 0.5,
      fillOpacity = 1,
      bringToFront = TRUE,
      sendToBack = TRUE
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal = params$pal,
    values = params$values,
    opacity = 0.9,
    title = txts[[params$var]]$lgd,
    labFormat = labelFormat(suffix = txts[[params$var]]$unit)) %>%
  addMarkers(
    lng = 2.351,
    lat = 48.856,
    popup = "When the Guerry dataset was published, around 800.000 people lived in the city of Paris")
```
:::



::: callout-note
## Exercise 7
Change the icon of the marker from exercise 6 to an icon depicting a city and the color to red.
:::

::: {.callout-tip collapse="true"}
To figure out how to change marker options, refer to `?makeIcon` and `?makeAwesomeIcon`.

For icons, take a look at the `library` argument and the website <https://fontawesome.com/>
:::

::: {.callout-warning collapse="true"}
## Solution

To change the color and the icon, we need to work with "awesome markers". Icons can be made with the function `makeAwesomeIcon()` or `makeIcon()`. These functions support Icons from Glyphicon, Fontawesome and Ionicon.

```{r eval=FALSE}
... %>%
  addAwesomeMarkers(
    lng = 2.351,
    lat = 48.856,
    popup = "When the Guerry dataset was published, around 800.000 people lived in the city of Paris",
    icon = makeAwesomeIcon(icon = "city", library = "fa", markerColor = "red")
  )
```
:::

::: callout-note
## Exercise 8
Set the default plotting variable to "Distance to Paris"
:::

::: {.callout-tip collapse="true"}
Remember the `selected` argument in input UI components
:::

::: {.callout-warning collapse="true"}
## Solution

To change the default values of a reactive Shiny plot, you need to change the `selected` argument of the UI input `selectInput`

```{r eval=FALSE}
selectInput(
  "tab_map_select",
  label = "Select a variable",
  choices = setNames(names(variable_names), variable_names),
  selected = "Distance"
)
```
:::

# Add context

- In the current state of the app, it's hard to know what exactly the variables represent
- Variables have informative titles, but this is not always enough
- In this subsection, we add additional context information to understand better what we're looking at

## Prepare context info

- As with many things, it's useful to prepare data before we use it
- Instead of relying on large `switch()` expressions, we create a list before running the server
- The list contains information on title, description, legend and unit
- Each list element can be accessed using the variable name so we can access them reactively

::: {.callout-tip}
For such large data objects, it can be a good idea to place them outside the main code file to increase readability.
:::

```{r echo=TRUE, results='hide'}
#| code-fold: true
#| code-summary: Create a list with context information
list(
  Crime_pers = list(
    title = "Crime against persons",
    desc = as.character(p(tags$b("Crime against persons:"), "Population per crime against persons", hr(), helpText("Source: Table A2 in Guerry (1833). Compte gÃ©nÃ©ral, 1825-1830"))),
    lgd = "Pop. per crime",
    unit = ""
  ),
  Crime_prop = list(
    title = "Crime against property",
    desc = as.character(p(tags$b("Crime against property:"), "Population per crime against property", hr(), helpText("Source: Compte gÃ©nÃ©ral, 1825-1830"))),
    lgd = "Pop. per crime",
    unit = ""
  ),
  Literacy = list(
    title = "Literacy",
    desc = as.character(p(tags$b("Percent Read & Write:"), "Percent of military conscripts who can read and write", hr(), helpText("Source: Table A2 in Guerry (1833)"))),
    lgd = "Literacy",
    unit = " %"
  ),
  Donations = list(
    title = "Donations to the poor",
    desc = as.character(p(tags$b("Donations to the poor"), hr(), helpText("Source: Table A2 in Guerry (1833). Bulletin des lois"))),
    lgd = "Donations",
    unit = ""
  ),
  Infants = list(
    title = "Illegitimate births",
    desc = as.character(p(tags$b("Population per illegitimate birth"), hr(), helpText("Source: Table A2 in Guerry (1833). Bureau des Longitudes, 1817-1821"))),
    lgd = "Pop. per birth",
    unit = ""
  ),
  Suicides = list(
    title = "Suicides",
    desc = as.character(p(tags$b("Population per suicide"), hr(), helpText("Source: Table A2 in Guerry (1833). Compte gÃ©nÃ©ral, 1827-1830"))),
    lgd = "Pop. per suicide",
    unit = ""
  ),
  Wealth = list(
    title = "Tax / capita",
    desc = as.character(p(tags$b("Per capita tax on personal property:"), "A ranked index based on taxes on personal and movable property per inhabitant", hr(), helpText("Source: Table A1 in Guerry (1833)"))),
    lgd = "Tax / capita",
    unit = ""
  ),
  Commerce = list(
    title = "Commerce & Industry",
    desc = as.character(p(tags$b("Commerce & Industry:"), "Commerce and Industry, measured by the rank of the number of patents / population", hr(), helpText("Source: Table A1 in Guerry (1833)"))),
    lgd = "Patents / capita",
    unit = ""
  ),
  Clergy = list(
    title = "Clergy",
    desc = as.character(p(tags$b("Distribution of clergy:"), "Distribution of clergy, measured by the rank of the number of Catholic priests in active service / population", hr(), helpText("Source: Table A1 in Guerry (1833). Almanach officiel du clergy, 1829"))),
    lgd = "Priests / capita",
    unit = ""
  ),
  Crime_parents = list(
    title = "Crime against parents",
    desc = as.character(p(tags$b("Crime against parents:"), "Crimes against parents, measured by the rank of the ratio of crimes against parents to all crimes \u2013 Average for the years 1825-1830", hr(), helpText("Source: Table A1 in Guerry (1833). Compte gÃ©nÃ©ral"))),
    lgd = "Share of crimes",
    unit = " %"
  ),
  Infanticide = list(
    title = "Infanticides",
    desc = as.character(p(tags$b("Infanticides per capita:"), "Ranked ratio of number of infanticides to population \u2013 Average for the years 1825-1830", hr(), helpText("Source: Table A1 in Guerry (1833). Compte gÃ©nÃ©ral"))),
    lgd = "Infanticides / capita",
    unit = ""
  ),
  Donation_clergy = list(
    title = "Donations to the clergy",
    desc = as.character(p(tags$b("Donations to the clergy:"), "Ranked ratios of the number of bequests and donations inter vivios to population \u2013 Average for the years 1815-1824", hr(), helpText("Source: Table A1 in Guerry (1833). Bull. des lois, ordunn. dâ€™autorisation"))),
    lgd = "Donations / capita",
    unit = ""
  ),
  Lottery = list(
    title = "Wager on Royal Lottery",
    desc = as.character(p(tags$b("Per capita wager on Royal Lottery:"), "Ranked ratio of the proceeds bet on the royal lottery to population \u2013 Average for the years 1822-1826", hr(), helpText("Source: Table A1 in Guerry (1833). Compte rendu par le ministre des finances"))),
    lgd = "Wager / capita",
    unit = ""
  ),
  Desertion = list(
    title = "Military desertion",
    desc = as.character(p(tags$b("Military desertion:"), "Military disertion, ratio of the number of young soldiers accused of desertion to the force of the military contingent, minus the deficit produced by the insufficiency of available billets\u2013 Average of the years 1825-1827", hr(), helpText("Source: Table A1 in Guerry (1833). Compte du ministÃ¨re du guerre, 1829 Ã©tat V"))),
    lgd = "No. of desertions",
    unit = ""
  ),
  Insturction = list(
    title = "Instruction",
    desc = as.character(p(tags$b("Instruction:"), "Ranks recorded from Guerry's map of Instruction. Note: this is inversely related to literacy (as defined here)")),
    lgd = "Instruction",
    unit = ""
  ),
  Prostitutes = list(
    title = "Prostitutes",
    desc = as.character(p(tags$b("Prostitutes in Paris:"), "Number of prostitutes registered in Paris from 1816 to 1834, classified by the department of their birth", hr(), helpText("Source: Parent-Duchatelet (1836),De la prostitution en Paris"))),
    lgd = "No. of prostitutes",
    unit = ""
  ),
  Distance = list(
    title = "Distance to paris",
    desc = as.character(p(tags$b("Distance to Paris (km):"), "Distance of each department centroid to the centroid of the Seine (Paris)", hr(), helpText("Source: Calculated from department centroids"))),
    lgd = "Distance",
    unit = " km"
  ),
  Area = list(
    title = "Area",
    desc = as.character(p(tags$b("Area (1000 km^2)"), hr(), helpText("Source: Angeville (1836)"))),
    lgd = "Area",
    unit = " km\u00b2"
  ),
  Pop1831 = list(
    title = "Population",
    desc = as.character(p(tags$b("Population in 1831, in 1000s"), hr(), helpText("Source: Taken from Angeville (1836), Essai sur la Statistique de la Population franÃ§ais"))),
    lgd = "Population (in 1000s)",
    unit = ""
  )
)
```


## Add variable descriptions

- To give a short description of the selected variable and their source, we add a new UI output

```{r eval=FALSE}
tabItem(
	tabName = "tab_map",
	fluidRow(
		column(                                     
			width = 4,                                
			box(                                      
				title = "Data selection",               
				status = "primary",                     
				width = 12,                             
				selectInput(                            
					"tab_map_select",                         
					label = "Select a variable",          
					choices = setNames(variable_names, names(variable_names))
				),                                      
				uiOutput("tab_map_desc")                    # <1>
			),
			box(                                      
				title = "Map configuration",            
				status = "primary",                     
				width = 12,                             
				radioButtons(                           
					"tab_map_aggr",                           
					label = "Aggregation level",          
					choices = c("Departments", "Regions"),
					selected = "Departments"              
				),                                      
				selectInput(                            
					"tab_map_pal",                            
					label = "Color palette",              
					choices = pals,                       
					selected = "Reds"                     
				) # end input
			) # end box
		), # end column
		column(
			width = 8,
			box(
				id = "tab_map_box",
				status = "primary",
				headerBorder = FALSE,
				collapsible = FALSE,
				width = 12,
				leaflet::leafletOutput("tab_map_map", height = "800px", width = "100%")
			) # end box
		) # end column
	) # end fluidRow
) # end tabItem
```

1. Add a UI output with the id `tab_map_desc`. This is where the variable description will go!

## Render context

```{r eval=FALSE}
  # Add a variable description
  output$tab_map_desc <- renderUI({         # <1>
    HTML(txts[[input$tab_map_select]]$desc) # <1>
  })                                        # <1>

	# Select polygon based on aggregation level (B)
	poly <- reactive({
		if (identical(input$tab_map_aggr, "Regions")) {
			data_guerry_region
		} else {
			data_guerry
		}
	})
	
	# Select palette based on input (C)
	palette <- reactive({
		pal <- input$tab_map_pal
		if (pal %in% pals$Viridis) {
			pal <- viridis::viridis_pal(option = tolower(pal))(5)
		}
		pal
	})
	
	# Compile parameters for leaflet rendering (D)
	params <- reactive({
		poly <- st_transform(poly(), 4326)
		pal <- palette()
		var <- input$tab_map_select
		
		values <- as.formula(paste0("~", var))
		pal <- colorNumeric(palette = pal, domain = NULL)
		
		list(
			poly = poly,
			var = var,
			pal = pal,
			values = values,
			labels = labels
		)
	})
	
	# Render leaflet for the first time
	output$tab_map_map <- leaflet::renderLeaflet({
		# Isolate call to params() to prevent render function to be executed
		# every time params() is invalidated. No dependency is made.
		params <- params()
		leaflet(data = params$poly) %>%
			addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
			addProviderTiles("OpenTopoMap", group = "OTM") %>%
			addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
			addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
			addLayersControl(baseGroups = c("OSM", "OTM",
																			"Stamen Toner", "Orthophotos")) %>%
			setView(lng = 3, lat = 47, zoom = 5) %>%
			addPolygons(
				fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
				fillOpacity = 0.7,
				weight = 1,
				color = "black",
				opacity = 0.5,
				highlightOptions = highlightOptions(
					weight = 2,
					color = "black",
					opacity = 0.5,
					fillOpacity = 1,
					bringToFront = TRUE,
					sendToBack = TRUE
				)
			) %>%
			addLegend(
				position = "bottomright",
				pal = params$pal,
				values = params$values,
				opacity = 0.9,
				title = txts[[params$var]]$lgd, # <2>
				labFormat = labelFormat(suffix = txts[[params$var]]$unit) # <2>
			)
	})
```

1. To render the UI, we call the `renderUI()` function. Here, we can just access the list we created before to access the description based on the selected variable.
2. In the same way, we can add a title and a unit to the legend using the `title` and `labFormat` arguments in `addLegend()`

- The result is arguably nicer to look at, but certainly provides more information to understand the map we created


## Full code

```{r eval=FALSE, file="shinyapps/guerry/states/06_mapping03.R"}
#| code-fold: true
#| code-summary: Full code including a reactive Leaflet map
```



# Add hover labels

- Unlike Plotly, Leaflet does not automatically provide labels for data points
    - Bad news: You have to do it on your own
    - Good news: You have more freedom in designing hover labels

## How to add labels

- Adding labels is itself not a difficult task: You can just provide the values vector we use as data input
- Labels then contain a single value with no information as to what you're looking at

```{r eval=FALSE}
leaflet() %>%
	addPolygons(
		..., # rest of the args
		label = ~values
	)
```

## Advanced label layout using HTML

- This is *enough*, but not very pretty and it doesn't provide potentially important metadata like region names
- In our app, we use a table layout containing information about region, department and variable value
- You can create generic HTML tables using the `table` tag (`tags$table`) together with the `tr` (table row, `tags$tr`) and `td` (table data, `tags$td`)

```{r}
tags$table(             # <1>
	tags$tr(              # <2>
		tags$td("Cell 1"),  # <3>
		tags$td("Cell 2"),  # <3>
		tags$td("Cell 3")   # <3>
	),
	tags$tr(            # <2>
		tags$td("Cell 4"),  # <3>
		tags$td("Cell 5"),  # <3>
		tags$td("Cell 6")   # <3>
	),
	tags$tr(            # <2>
		tags$td("Cell 7"),  # <3>
		tags$td("Cell 8"),  # <3>
		tags$td("Cell 9")   # <3>
	)
)
```

1.  Define the table environment
2.  Define a table row
3.  Define three data cells

![](https://vertex-academy.com/tutorials/wp-content/uploads/2016/08/table.png)

- In the following chunk we use `mapply()` to map region, department and variable value into a nicely aligned grid:

```{r eval=FALSE}
params <- reactive({
  poly <- st_transform(poly(), 4326)
  pal <- palette()
  var <- input$tab_map_select

  values <- as.formula(paste0("~", var))
  pal <- colorNumeric(palette = pal, domain = NULL)
  
  reg <- poly[["Region"]]     # <1>
  dep <- poly[["Department"]] # <1>
  val <- poly[[var]]          # <1>
  
  # If aggregated on region level, department will be NULL
  if (is.null(dep)) {         # <2>
    dep <- rep(NA, nrow(poly))# <2>
  }                           # <2>

  # Create labels that are nicely aligned in a grid
  # If aggregated on region level, omit department name (because it is NULL)
  labels <- mapply(           # <3>
    function(reg, dep, val) { # <3>
      HTML(as.character(tags$table( # <4>
      	# Add region row
        tags$tr( # <5>
          style = "line-height: 10px", # more compact layout
          tags$td(tags$b("Region: ")), # <6>
          tags$td(reg)                 # <7>
        ),
        # Add department row if available
        if (!is.na(dep)) {
          tags$tr( # <5>
            style = "line-height: 10px",
            tags$td(tags$b("Department: ")), # <6>
            tags$td(dep)                     # <7>
          )
        },
        # Add value row
        tags$tr( # <5>
          style = "line-height: 10px",
          tags$td(tags$b(paste0(txts[[var]]$lgd, ": "))), # <6>
          tags$td(round(val, 2))                          # <7>
        )
      )))
    },
    reg = reg, dep = dep, val = val,
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE
  )

  list(
    poly = poly,
    var = var,
    pal = pal,
    values = values,
    labels = labels # <8>
  )
  
  # Render leaflet for the first time
  output$tab_map_map <- leaflet::renderLeaflet({
    params <- params()
    leaflet(data = params$poly) %>%
      addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
      addProviderTiles("OpenTopoMap", group = "OTM") %>%
      addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
      addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
      addLayersControl(baseGroups = c("OSM", "OTM",
                                      "Stamen Toner", "Orthophotos")) %>%
      setView(lng = 3, lat = 47, zoom = 5) %>%
      addPolygons(
        fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
        fillOpacity = 0.7,
        weight = 1,
        color = "black",
        opacity = 0.5,
        label = params$labels, # <9>
        highlightOptions = highlightOptions(
          weight = 2,
          color = "black",
          opacity = 0.5,
          fillOpacity = 1,
          bringToFront = TRUE,
          sendToBack = TRUE
        )
      ) %>%
      addLegend(
        position = "bottomright",
        pal = params$pal,
        values = params$values,
        opacity = 0.9,
        title = txts[[params$var]]$lgd,
        labFormat = labelFormat(suffix = txts[[params$var]]$unit)
      )
  })
})
```

1.  Store all relevant information, this includes: the region names, the department names and the variable values
2.  In case the map is aggregated, the department names are going to be `NULL`. To prevent errors down the line, we replace it with `NA` the same length as the other vectors.
3.  Then, we apply a function to the three vectors parallely, so that we can work with all label values at the same time
4.  Create a table environment
5.  Create three rows, one for each vector: regions, departments and values
6.  The first cell is the left-hand side (e.g. "Department" or "Region")
7.  The second cell is the right-hand side (e.g. the department name)
8.  Add the newly created labels to the `params()` list
9.  Don't forget to pass the labels to the leaflet maps using the `labels` parameter!

![](resources/06_04.gif)

# Add proxies

- The map already looks quite polished!
- One more problem: Map updates!
- Map re-renders every time an input is invalidated:
    - Everything needs to be redrawn = slow for large datasets
    - Map view resets with every update:

![](resources/06_05.gif)

## What are proxies?

- Solution: Proxies
- Proxy objects are representations of existing widgets that can manipulate widgets in place

## Proxies in Shiny extensions

- Many Shiny extensions provide proxy functions:
    - [`DT::dataTableProxy()`](https://rdrr.io/cran/DT/man/proxy.html)
    - [`plotly::plotlyProxy()`](https://rdrr.io/cran/plotly/man/plotlyProxy.html)
    - [`leaflet::leafletProxy()`](https://rdrr.io/cran/leaflet/man/leafletProxy.html)

## Proxy workflow

1.  Initialize an isolated output widget (i.e., no dependencies) / `output$tab_map_map`
2.  Create an observer that updates input dependencies / `observe()`
3.  Invalidate an input
4.  Remove existing features and add new ones

![Reactive graph for proxies](resources/proxies.svg)

## Isolate reactive objects

- To create an isolated output widget, we use the `isolate()` function from Shiny
    - The `params()` reactive is executed only *once*, but does take a dependency

```{r eval=FALSE}
  # Render leaflet for the first time
  output$tab_map_map <- leaflet::renderLeaflet({
    params <- isolate(params()) # <1>
    leaflet(data = params$poly) %>%
      addProviderTiles("OpenStreetMap.France", group = "OSM") %>%
      addProviderTiles("OpenTopoMap", group = "OTM") %>%
      addProviderTiles("Stamen.TonerLite", group = "Stamen Toner") %>%
      addProviderTiles("GeoportailFrance.orthos", group = "Orthophotos") %>%
      addLayersControl(baseGroups = c("OSM", "OTM",
                                      "Stamen Toner", "Orthophotos")) %>%
      setView(lng = 3, lat = 47, zoom = 5) %>%
      addPolygons(
        fillColor = as.formula(paste0("~params$pal(", params$var, ")")),
        fillOpacity = 0.7,
        weight = 1,
        color = "black",
        opacity = 0.5,
        label = params$labels,
        highlightOptions = highlightOptions(
          weight = 2,
          color = "black",
          opacity = 0.5,
          fillOpacity = 1,
          bringToFront = TRUE,
          sendToBack = TRUE
        )
      ) %>%
      addLegend(
        position = "bottomright",
        pal = params$pal,
        values = params$values,
        opacity = 0.9,
        title = variable_desc[[params$var]]$lgd,
        labFormat = labelFormat(suffix = variable_desc[[params$var]]$unit)
      )
  })
```

1.  Most of the code remains the same. However, we isolate the call to `params()` to prevent the rendering function to execute every time `params()` is invalidated. No dependency is taken!

## Implement proxies

- Instead, we create an observer that updates the map layers *in place*
- First, all existing features that are to be changed are cleared
- Second, new features are added in the usual piping manner

```{r eval=FALSE}
  observe({ # <1>
    params <- params() # <2>
    leafletProxy("tab_map_map", data = params$poly) %>% # <3>
      clearShapes() %>% # <4>
      clearControls() %>% # <4>
      addPolygons( # <5>
        fillColor = as.formula(paste0("~params$pal(", params$var, ")")), # <5>
        fillOpacity = 0.7, # <5>
        weight = 1, # <5>
        color = "black", # <5>
        opacity = 0.5, # <5>
        label = params$labels, # <5>
        highlightOptions = highlightOptions( # <5>
          weight = 2, # <5>
          color = "black", # <5>
          opacity = 0.5, # <5>
          fillOpacity = 1, # <5>
          bringToFront = TRUE, # <5>
          sendToBack = TRUE # <5>
        ) # <5>
      ) %>% # <5>
      addLegend( # <5>
        position = "bottomright", # <5>
        na.label = "No data", # <5>
        pal = params$pal, # <5>
        values = params$values, # <5>
        opacity = 0.9, # <5>
        title = variable_desc[[params$var]]$lgd, # <5>
        labFormat = labelFormat(suffix = variable_desc[[params$var]]$unit) # <5>
      ) # <5>
  }) # <5>
```

1.  Proxies work with observers. There is no need to use a rendering function as the widget is re-rendered but an existing widget is updated.
2.  `params()` can be called without isolation here!
3.  Create a leaflet proxy. Proxies update map values without re-rendering the entire map, thus increasing performance.
4.  Remove existing layers because we don't want to stack layers infinitely
5.  Add new layers in the same way you would with a normal leaflet map

## What changed?

- The output now:
    - Does not re-render from scratch - saving time and resources
    - Does not reset the map - making exploration more seamless

![](resources/06_06.gif)

# Access Shiny events on maps

- Currently the user can interact with the Leaflet map in various ways: zoom, pan, hover, ...
- The Shiny programmer has no way of accessing what happens on the map after it is rendered
- Solution: **reactive events!**
- Many Shiny extensions like Leaflet allow you to observe events that happen on the map

## Leaflet events

- Leaflet events are accessed like so:

::: {style="font-size: 20px;"}
`input$<Map ID>`{style="color: red;"}`_<Object type>`{style="color: green;"}`_<Event type>`{style="color: blue;"}
:::

- Map ID refers to the ID given to the Leaflet widget, in our case this is `map_exp`

## Leaflet object types

- Object type refers to a geometry type, can be one of:
    - `marker` for points
    - `shape` for polygons and lines
    - `geojson` and `topojson` for data that was passed in GeoJSON or TopoJSON format

## Leaflet event types

- Event type refers to the action that is performed on the geometry, one of:
    - `click`
    - `mouseover`
    - `mouseout`

## Other events

- Additionally, Leaflet has some more general events:
    - `input$<Map ID>_click` triggers when the background of the map is clicked
    - `input$<Map ID>_bounds` provides the bounding box of the current view
    - `input$<Map ID>_zoom` provides the current zoom level
    - `input$<Map ID>_center` provides the center point of the current view
- **Question:** When does `input$tab_map_map_marker_click` trigger?

## Events in practice

- The output of these Leaflet events usually contain an ID, Latitude and Longitude:

```{r include=FALSE}
input <- list()
input$tab_map_map_shape_click <- list(id = NULL, .nonce = 0.0504539489632481, lat = 49.003195289566, lng = -1.14056772662844)
```

```{r}
input$tab_map_map_shape_click
```

## Clear objects

- In the following code chunk, we add a marker whenever we click on a polygon on the Leaflet map
    1.  Capture the click input
    2.  Remove previous markers
    3.  Add a new marker using the click coordinates

```{r eval=FALSE}
observe({
	click <- input$tab_map_map_shape_click # <1>
	req(click) # <2>
	leafletProxy("tab_map_map") %>% # <3>
		clearMarkers() %>% # <4>
		addMarkers(lng = click$lng, lat = click$lat) # <5>
})
```

1.  Store event object. The event is invalidated when a user clicks on a shape in the `tab_map_map` leaflet widget
2.  Cancel the observer when the click object is not "truthy" (see `?isTruthy`). If nothing is clicked, the observer should not be run.
3.  Create a Leaflet proxy
4.  Clear the previous marker
5.  Add a new marker

![](resources/06_07.gif)

- Here, we remove all markers in order to add a new one, but we can also be more careful in deleting elements
    - `leaflet::clear` functions remove all elements of a geometry type
    - `leaflet::remove` functions remove one element by layer ID

::: callout-note
`leaflet::remove` functions need a layer ID to work! You can set them using the `layerId` argument in `leaflet::add` functions, e.g. `leaflet::addMarkers(..., layerId = "marker1")`
:::

```{r eval=FALSE}
# Add a new marker
observe({
	click <- input$tab_map_map_shape_click
	req(click)
	id <- paste0(click$lng, click$lat) # <1>
	leafletProxy("tab_map_map") %>%
		addMarkers(lng = click$lng, lat = click$lat, layerId = id) # <2>
})

# Delete an existing marker
observe({
	click <- input$tab_map_map_marker_click
	req(click)
	leafletProxy("tab_map_map") %>%
		removeMarker(click$id) # <3>
})
```

1.  Generate an ID from long/lat so we know exactly what element we are talking about
2.  Pass the generated ID to a marker that we add
3.  When clicking on a new marker again, we can know exactly what marker to delete and do not need to delete everything

![](resources/06_08.gif)

::: {.callout-note collapse="true"}
## Bonus for the daring

- You can create your own input events with a little bit of JavaScript!
- In the code chunk below, we add a "mousemove" event, that triggers every time the mouse is moved on the Leaflet map
- Note the use of `htmlwidgets::onRender()` to execute a piece of JavaScript when the Leaflet widget renders
- Note the use of `Shiny.onInputChange` to create input events
- Further reading: [Joe Cheng - "Communicating with Shiny via JavaScript"](https://shiny.posit.co/r/articles/build/communicating-with-js/)

```{r eval=FALSE}
output$tab_map_map <- renderLeaflet({
	leaflet() %>%
		htmlwidgets::onRender("function(el, x) {
      this.on('mousemove', function(e) {
        var lng = e.latlng.lng;
        var lat = e.latlng.lat;
        var coord = [lng, lat];            // capture long and lat
        Shiny.onInputChange('tab_map_map', coord)   // send coordinates to Shiny
      });
      this.on('mouseout', function(e) {
        Shiny.onInputChange('tab_map_map', null)    // reset coordinates when mouse leaves map
      })
    }")
})
```
:::

## Full code

```{r eval=FALSE, file="shinyapps/guerry/states/06_mapping05.R"}
#| code-fold: true
#| code-summary: Full code including Shiny events
```



## Exercises

::: callout-note
## Exercise 9

When does the event `input$map_exp_shape_mouseout` send information to the server?
:::

::: {.callout-tip collapse="true"}
A Leaflet input event is structured as follows: `input$<mapid>_<geometry type>_<event type>`.
:::

::: {.callout-warning collapse="true"}
## Solution

`map_exp` refers to the target leaflet map

`shape` refers to the target map object (in this case a polygon or a line)

`mouseout` refers to the event type

`input$map_exp_shape_mouseout` triggers whenever we move out of the boundaries of a polygon on the Leaflet map with the ID `map_exp`
:::

::: callout-note
## Exercise 10

Print the current mouse coordinates to the console every time a polygon on the map is clicked.
:::

::: {.callout-tip collapse="true"}
You can access click coordinates using the map event `input$tab_map_map_shape_click`
:::

::: {.callout-warning collapse="true"}
## Solution

To capture the the mouse coordinates we need to access the Leaflet event `input$tab_map_map_shape_click`. Printing to the console is done in an observer as it triggers side effects and does not create a reactive object.

```{r eval=FALSE}
observe({
	click <- input$tab_map_map_shape_click
	cat(paste(
		"Click on tab_map_map detected",
		paste("Lon:", click$lng),
		paste("Lat:", click$lat),
		"\n",
		sep = "\n"
	))
})
```
:::
