---
title: "Good practices when building your own app"
---

```{r, include=FALSE}
library(dplyr)
library(shiny)
```


- Learning outcomes:
  - Good practices for Shiny programming
  - Typical pitfalls to watch out for
  - Useful everyday Shiny workflows
  
  
  
## Paul

### Use Large Language Models (LLMs)




## Jonas

### Use the browser inspector

- Browser inspectors are an extremely powerful tool that goes far beyond the scope of this workshop
- It can be used to take a deep look at a website
  - What colors and fonts are used?
  - How would the Shiny app look like on different screen sizes?
  - How would the Shiny app look like to color-blind people?
  - How are UI elements translated to HTML and CSS?
  - How are widths and heights translated to pixels?
  - Which HTTP requests are sent when running the Shiny app?
  - Does my website evoke any client-side errors?
  - ... and a lot more
- Every popular browser has its own implementation of an inspector
  - [Firefox Page Inspector](https://firefox-source-docs.mozilla.org/devtools-user/page_inspector/)
  - [Chrome DevTools](https://developer.chrome.com/docs/devtools)
  - [Opera Web Inspector](https://dev.opera.com/extensions/testing/)
  - [Edge Inspect Tool](https://learn.microsoft.com/en-en/microsoft-edge/devtools-guide-chromium/css/inspect)
  - [Safari Web Inspector](https://developer.apple.com/documentation/safari-developer-tools/web-inspector)
- Inspectors are useful for:
  - Conveying an understanding of essential HTML and CSS
  - Fine-tuning the UI of a Shiny app
  - Implementing corporate designs
- Inspectors are **excessive** if:
  - The goal is primarily to get a functioning app
  - Exploring a new elaborate tool beyond Shiny is a bit too much


### Organize your code

- Shiny code becomes messy **really** quick!
- It is even more important than in normal code to keep code clean and tidy
- Why should I organize my code?
  - It is easier for colleagues to quickly grasp what your code does
  - It is easier for you to get back to your project after some time
  - Programming with organized code is much faster and much more fun


#### What does code organisation entail?

##### Functional programming
- Wrap code in functions if:
  - It is repeated more than two times
  - It is complex and might profit from abstraction
- Bad:
```{r, eval=FALSE}
exp(mean(log(iris$Sepal.Length)))
exp(mean(log(iris$Sepal.Width)))
exp(mean(log(iris$Petal.Length)))
exp(mean(log(iris$Petal.Width)))
```
- Good:
```{r, eval=FALSE}
geometric_mean <- function(x) exp(mean(log(x)))
summarize(iris, across(where(is.numeric), geometric_mean))
```
  
##### Stick to a style guide
- Adopting a consistent coding style drastically improves readability for yourself and contributors
- The [styler](https://styler.r-lib.org/) and [lintr](https://lintr.r-lib.org/) packages automatically check your code for style inconsistencies, bad practictes, and possible syntactic/semantic errors
- The following code is valid, but deciphering what's going on might take a while
  
```{r, eval=FALSE}
ui<-fluidPage(selectInput("var"
            ,"Variable"
            ,names(mtcars))
  ,numericInput("bins","bins",10,min= 1)
  , plotOutput("hist"))
server<-
function(
input,output,session
) {
  data<-
    reactive(mtcars[[input$var]])
  output$hist<-
    renderPlot(
    {hist(data()
          ,breaks=input$bins
          ,main=input$var)},res =96
)}
```

  
##### Annotate your code

- Even in smaller apps, Shiny code is multiple hundred lines long
- RStudio annotations can help navigate large R code files

```{r}
# Header 1 ----
## Header 1.1 ----
### Header 1.1.1 ----
### Header 1.1.2 ----
# Header 2 ----
```
  
  ![Example of an RStudio outline](resources/rstudio_toc.png)
  
##### Modularize your Shiny code
- If your Shiny app is divided into multiple tabs or sections, it might make sense to wrap it into modules
- By modularizing, you divide a large Shiny app into multiple smaller pieces that are isolated from each other
- Modularization is a very advanced topic and there is an [entire chapter in Mastering Shiny](https://mastering-shiny.org/scaling-modules.html) -- but it is good to know that it's possible
  
![Example of a modularized app](https://d33wubrfki0l68.cloudfront.net/3d9a229fec717ef7bfda8e17a9c9d4fdc66b8b08/953f7/diagrams/scaling-modules/after.png)
  
##### Build your Shiny app as a package
- This tip is particularly useful for larger apps
- The idea is to build a robust scaffold around the Shiny app
- A number of R packages specialize on this task: [Rhino](https://appsilon.github.io/rhino/) [golem](https://thinkr-open.github.io/golem/), and [leprechaun](https://leprechaun.opifex.org/)
- Benefits:
  - Automatically handles dependencies, no more `library` and `there is no package called ‘xxx’`
  - Facilitates sharing Shiny apps without deployment
  - Supports multiple Shiny apps in one app
  - Enables testing workflows and thus more robust code
  - All R code files in one place
=======
(show, don't tell!)
>>>>>>> fa21f429c79006ffd6830cf984b7fafa6f63f9a3
